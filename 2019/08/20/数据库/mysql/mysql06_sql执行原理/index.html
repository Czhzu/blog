<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一条sql执行过程">
<meta name="keywords" content="mysql">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql06_sql执行原理">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;08&#x2F;20&#x2F;%E6%95%B0%E6%8D%AE%E5%BA%93&#x2F;mysql&#x2F;mysql06_sql%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86&#x2F;index.html">
<meta property="og:site_name" content="Chenaa&#39;s Notes">
<meta property="og:description" content="一条sql执行过程">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;mysql&#x2F;mysql_06_01.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;mysql&#x2F;mysql_06_02.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;mysql&#x2F;mysql_06_03.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;mysql&#x2F;mysql_06_04.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;mysql&#x2F;mysql_06_05.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;mysql&#x2F;mysql_06_09.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;mysql&#x2F;mysql_06_06.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;mysql&#x2F;mysql_06_07.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;mysql&#x2F;mysql_06_08.jpg">
<meta property="og:updated_time" content="2020-05-25T00:31:17.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;mysql&#x2F;mysql_06_01.png">

<link rel="canonical" href="http://yoursite.com/2019/08/20/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql06_sql%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>mysql06_sql执行原理 | Chenaa's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chenaa's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">尘事如潮人如水</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/20/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql06_sql%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="chenaa">
      <meta itemprop="description" content="zZ..zZ..">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenaa's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mysql06_sql执行原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-20 20:30:00" itemprop="dateCreated datePublished" datetime="2019-08-20T20:30:00+08:00">2019-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-25 08:31:17" itemprop="dateModified" datetime="2020-05-25T08:31:17+08:00">2020-05-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一条sql执行过程"><a href="#一条sql执行过程" class="headerlink" title="一条sql执行过程"></a>一条sql执行过程</h1><p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/mysql/mysql_06_01.png" alt=""></p>
<a id="more"></a>

<h1 id="客户端-服务器通信流程"><a href="#客户端-服务器通信流程" class="headerlink" title="客户端/服务器通信流程"></a>客户端/服务器通信流程</h1><p>My SQL客户端和服务器之间的通信协议是“<strong>半双工</strong>”的,这意味着,在任何一个时刻,要么是由服务器向客户端发送数据,要么是由客户端向服务器发送数据,这两个动作不能同时发生。</p>
<p>一般服务器响应给用户的数据通常很多,由多个数据包组成。当服务器开始响<br>应客户端请求时,<strong>客户端必须完整地接收整个返回结果</strong>,而不能简单地只取前面几条结果,然后让服务器停止发送数据。</p>
<p>客户端缓存服务端返回的结果，Mysql服务端只有所有数据都发送给客户端才能释放这条查询所占用的资源。</p>
<h2 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h2><p>对于一个 My SQL连接,或者说一个线程,任何时刻都有一个状态,该状态表示了MySQL当前正在做什么。有很多种方式能查看当前的状态,最简单的是使用 SHOW FULL PROCESSLIST命令。</p>
<p>在一个查询的生命周期中,状态会变化很多次。 My SQL官方手册中对这些状态值的含义有最权威的解释,下面将这些状态列出来,并做一个简单的解释。</p>
<ul>
<li><p><strong>Sleep</strong> 线程正在等待客户端发送新的请求。</p>
</li>
<li><p><strong>Query</strong> 线程正在执行查询或者正在将结果发送给客户端。</p>
</li>
<li><p><strong>Locked</strong> 在MySQL服务器层,该线程正在<strong>等待表锁</strong>。<strong>在存储引擎级别实现的锁,例如InnodB的行锁,并不会体现在线程状态中。</strong></p>
</li>
<li><p><strong>Analyzing and statistics</strong> 线程正在收集存储引擎的统计信息,并生成查询的执行计划。</p>
</li>
<li><p><strong>Copying to tmp table [on disk]</strong> 线程正在执行查询,并且将其结果集都复制到一个临时表中,这种状态一般要么是在做 GROUP BY操作,要么是文件排序操作,或者是UNION操作。如果这个状态后面<br>还有“ on disk”标记,那表示 MySQL正在将一个内存临时表放到磁盘上</p>
</li>
<li><p><strong>Sorting result</strong> 线程正在对结果集进行排序</p>
</li>
<li><p><strong>Sending data</strong> 这表示多种情况:线程可能在多个状态之间传送数据,或者在生成结果集,或者在向客户端返回数据。</p>
</li>
</ul>
<h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><p>在解析一个查询语句之前,如果查询缓存是打开的,那么 <strong>MySQL会优先检查这个查询是否命中查询缓存中的数据</strong>。这个检查是通过一个对大小写敏感的哈希査找实现的。<strong>查询和缓存中的查询即使只有一个字节不同,那也不会匹配缓存结果,</strong>这种情况下查询就会进入下一阶段的处理。</p>
<p>如果当前的查询恰好命中了查询缓存,那么在返回查询结果之前 My SQL会检查一次用户权限。如果权限没有问题, MySQL会跳过所有其他阶段,直接从缓存中拿到结果并返回给客户端。这种情况下,查询不会被解析,不用生成执行计划,不会被执行。</p>
<h1 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h1><p>查询的生命周期的下一步是将一个SQL转换成一个执行计划, MySQL再依照这个执行计划和存储引擎进行交互。这包括多个子阶段:<strong>解析SQL</strong>、<strong>预处理</strong>、<strong>优化SQL执行计划</strong>。</p>
<p>这个过程中任何错误(例如语法错误)都可能终止查询,在实际执行中,这几部分<strong>可能一起起执行，也可能单独执行。</strong></p>
<h2 id="语法解析器"><a href="#语法解析器" class="headerlink" title="语法解析器"></a>语法解析器</h2><p>MySQL通过关键字将SQL语句进行解析,并生成一棵对应的“解析树”MySQL解析器将使用 MySQL语法规则验证和解析查询。</p>
<h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p>预处理器则根据一些MySQL规则进一步检査解析树是否合法,例如,这里将检查数据表和数据列是否存在,还会解析名字和别名,看看它们是否有歧义。</p>
<p>下一步预处理器会验证权限。</p>
<h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p>一条查询可以有很多种执行方式,最后都返回相同的结果。<strong>优化器的作用就是找到这其中最好的执行计划。</strong></p>
<p><strong>MySQL使用基于成本的优化器</strong>,它将尝试预测一个查询使用某种执行计划时的成本,并选择其中成本最小的一个。</p>
<p><strong>执行计划的成本是由mysql根据一系列的统计信息计算得来的</strong>:每个表或者索引的页面个数、索引的基数(索引中不同值的数量)、索引和数据行的长度、索引分布情况。</p>
<p>有很多种原因会导致 MySQL优化器选择错误的执行计划,如 统计信息不准确、 执行计划中的成本估算不等同于实际执行的成本、<strong>优化器有时候无法去估算所有可能的执行计划,所以它可能错过实际上最优的执行计划</strong>。</p>
<h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><p>MySQL的査询优化器是一个非常复杂的部件,它使用了很多优化策略来生成一个最优的执行计划。</p>
<p>优化策略可以简单地分为两种。</p>
<ul>
<li><p>静态优化</p>
<blockquote>
<p>   静态优化可以直接对解析树进行分析,并完成优化。例如,优化器可以通过一些简单的代数变换将WHERE条件转换成另一种等价形式。静态优化在第一次完成后就一直有效,即使使用不同的参数重复执行查询也不会发生变化。可以认为这是一种“编译时优化”。</p>
</blockquote>
</li>
<li><p>动态优化</p>
<blockquote>
<p>   动态优化则和查询的上下文有关,也可能和很多其他因素有关,例如 WHERE条件中的取值、索引中条目对应的数据行数等。这需要在每次查询的时候都重新评估,可以认为这是“运行时优化”。</p>
</blockquote>
</li>
</ul>
<h3 id="优化器能够处理的优化类型"><a href="#优化器能够处理的优化类型" class="headerlink" title="优化器能够处理的优化类型"></a>优化器能够处理的优化类型</h3><ol>
<li><p>重新定义关联表的顺序</p>
</li>
<li><p>将外连接转为内连接</p>
</li>
<li><p>使用等价变换规则</p>
<blockquote>
<pre><code>( a\&lt;b AND b=c) AND a=5 会被改写为 b&gt;5 </code></pre></blockquote>
</li>
<li><p>优化COUNT(),MIN(),MAX()</p>
</li>
<li><p>覆盖索引扫描</p>
</li>
<li><p>子查询优化</p>
</li>
<li><p>等值传播</p>
</li>
<li><p>提前终止查询</p>
</li>
</ol>
<h3 id="生成执行计划"><a href="#生成执行计划" class="headerlink" title="生成执行计划"></a>生成执行计划</h3><p><strong>MySQL生成査询的一棵指令树,然后通过存储引擎执行完成这棵指令树并返回结果。</strong></p>
<p>最终的执行计划包含了重构查询的全部信息。如果对某个查询执行 EXPLATN EXIENDED后,再执行SHOW WARNINGS,就可以看到重构出的查询。</p>
<p>任何多表查询都可以使用一棵树表示,例如<br><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/mysql/mysql_06_02.png" alt=""></p>
<p> MySQL总是从一个表开始一直嵌套循环、回溯完成所有表关联。(见mysql如何关联表)</p>
<p><strong>MySQL的执行计划总是一棵左测深度优先的树。</strong><br> <img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/mysql/mysql_06_03.png" alt=""></p>
<h3 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h3><p><strong>My SQL优化器最重要的一部分就是关联查询优化,它决定了多个表关联时的顺序。</strong> </p>
<p>通常多表关联的时候,可以有多种不同的关联顺序来获得相同的执行结果。关联查询优化器则通过评估不同顺序时的成本来选择一个代价最小的关联顺序。</p>
<blockquote>
<p>   mysql会自动优化多表关联时的关联顺序，但是写sql的时候还是自己心里要有数</p>
</blockquote>
<p>如果有超过n个表的关联,那么需要检查n的阶乘种关联顺序。我们称之为所有可能的执行计划的“搜索空间”,搜索空间的增长速度非常块—一例如,若<br>是10个表的关联,那么共有3628800种不同的关联顺序!当搜索空间非常大的时候,优化器不可能逐一评估毎一种关联顺序的成本。这时,优化器选择使用“贪婪”搜索的方式查找“最优”的关联顺序。</p>
<p>这也是之前提的，mysql使用了错误的执行计划原因之一，<strong>优化器有时候无法去估算所有可能的执行计划,所以它可能错过实际上最优的执行计划</strong>。</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><strong>排序都是一个成本很高的操作,所以从性能角度考虑,应尽可能避免排序或者尽可能避免对大量数据进行排序。</strong><br>如果需要排序，MySQL会对查询出来的结果进行排序。</p>
<ol>
<li>通过索引排序</li>
<li>无法使用索引排序的时候，进行文件排序</li>
</ol>
<h2 id="MySQL如何关联查询-JOIN原理"><a href="#MySQL如何关联查询-JOIN原理" class="headerlink" title="MySQL如何关联查询(JOIN原理)"></a>MySQL如何关联查询(JOIN原理)</h2><p>MySQL中“关联(join)”一词所包含的意义比一般意义上理解的要更广泛。</p>
<p>总的来说,MySQL认为任何一个查询都是一次“关联”一一并不仅仅是一个查询需要到两个表匹配才叫关联,所以在 MySQL中,每一个查询,每一个片段(包括子查询,甚至基于单表的 SELECT都可能是关联。</p>
<p><strong>对于UNI0N查询</strong>, <strong>MySQL先将一系列的单个查询结果放到一个临时表</strong>中,然后再重新读出临时表数据来完成UNI0N查询。</p>
<p><strong>MySQL对任何关联都执行嵌套循环关联操作</strong>,即My SQL先在一个表中循环取出单条数据,然后再嵌套循环到下一个表中寻找匹配的行,依次下去,直到找到所有表中匹配的行为止。然后根据各个表匹配的行,返回查询中需<br>要的各个列。</p>
<p>参考上面的图，mysql如何实现多表关联。</p>
<p><strong>Join的过程中具体做了什么呢？</strong></p>
<p>数据准备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t2` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `a` int(11) DEFAULT NULL,</span><br><span class="line">  `b` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `a` (`a`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">drop procedure idata;</span><br><span class="line">delimiter ;;</span><br><span class="line">create procedure idata()</span><br><span class="line">begin</span><br><span class="line">  declare i int;</span><br><span class="line">  set i=1;</span><br><span class="line">  while(i&lt;=1000)do</span><br><span class="line">    insert into t2 values(i, i, i);</span><br><span class="line">    set i=i+1;</span><br><span class="line">  end while;</span><br><span class="line">end;;</span><br><span class="line">delimiter ;</span><br><span class="line">call idata();</span><br><span class="line"></span><br><span class="line">create table t1 like t2;</span><br><span class="line">insert into t1 (select * from t2 where id&lt;=100)</span><br></pre></td></tr></table></figure>
<h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 straight_join t2 on (t1.a=t2.a);</span><br></pre></td></tr></table></figure>
<p>用straight_join让MySQL使用固定的连接方式执行查询，在这个语句里，t1 是驱动表，t2是被驱动表。</p>
<p>这条语句的explain结果</p>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/mysql/mysql_06_04.png" alt=""><br><strong>被驱动表t2的字段a上有索引</strong>，join过程用上了这个索引，因此这个语句的执行流程是这样的：</p>
<ol>
<li>从表t1中读入一行数据 R；</li>
<li>从数据行R中，取出a字段到表t2里去查找；</li>
<li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</li>
<li>重复执行步骤1到3，直到表t1的末尾循环结束。<br><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/mysql/mysql_06_05.jpg" alt=""></li>
</ol>
<p>这个过程是先遍历表t1，然后根据从表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且<strong>可以用上被驱动表的索引，所以我们称之为“Index Nested-Loop Join”，简称NLJ。</strong></p>
<p>对驱动表t1做了全表扫描，这个过程需要扫描100行；而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描100行；所以，整<strong>个执行流程，总扫描行数是200。</strong></p>
<p><strong>NLJ优化</strong></p>
<p><strong>MRR(Multi-Range Read),优化回表操作，根据索引找到主键后，根据主键排序后去回表查询，将原来的随机读写改成了顺序读写，极大的提高了读性能</strong></p>
<p><strong>Batched Key Access</strong></p>
<p>理解了MRR性能提升的原理，我们就能理解MySQL在5.6版本后开始引入的Batched Key Acess(BKA)算法了。这个BKA算法，其实就是对NLJ算法的优化。</p>
<p>NLJ算法执行的逻辑是：从驱动表t1，一行行地取出a的值，再到被驱动表t2去做join。也就是说，对于表t2来说，每次都是匹配一个值。这时，MRR的优势就用不上了。</p>
<p>那怎么才能一次性地多传些值给表t2呢？方法就是，从表t1里一次性地多拿些行出来，一起传给表t2。</p>
<p>把表t1的数据取出来一部分，先放到一个临时内存。这个临时内存不是别人，就是join_buffer,一次性传给t2，<strong>t2可以匹配的时候可以根据索引顺序读。</strong></p>
<p><strong>一次性多传些值给t2，就是BAK算法。</strong></p>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/mysql/mysql_06_09.jpg" alt=""></p>
<h3 id="Simple-Nested-Loop-Join-mysql不使用这种方式"><a href="#Simple-Nested-Loop-Join-mysql不使用这种方式" class="headerlink" title="Simple Nested-Loop Join(mysql不使用这种方式)"></a>Simple Nested-Loop Join(mysql不使用这种方式)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 straight_join t2 on (t1.a=t2.b);</span><br></pre></td></tr></table></figure>

<p>由于表t2的字段b上没有索引，因此再用图2的执行流程时，每次到t2去匹配的时候，就要做一次全表扫描。这样算来，这个SQL请求就要扫描表t2多达100次，总共扫描100*1000=10万行。</p>
<p>这还只是两个小表，如果t1和t2都是10万行的表（当然了，这也还是属于小表的范围），就要扫描100亿行，这个算法看上去太“笨重”了。</p>
<h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h3><p><strong>被驱动表上没有可用的索引,mysql使用Block Nested-Loop Join(BNL)算法</strong><br>算法的流程是这样的：</p>
<ol>
<li><p>把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存；</p>
</li>
<li><p>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。</p>
</li>
</ol>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/mysql/mysql_06_06.jpg" alt=""></p>
<p>这条SQL语句的explain结果如下所示：<br><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/mysql/mysql_06_07.png" alt=""></p>
<p>在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的判断次数是：100*1000=10万次。</p>
<p>因此，从时间复杂度上来说，这两个算法是一样的。但是，<strong>Block Nested-Loop Join算法的这10万次判断是内存操作，速度上会快很多，性能也更好。</strong></p>
<p><strong>要是表t1是一个大表，join_buffer放不下怎么办呢？</strong><br>join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。</p>
<p>如果放不下表t1的所有数据话，策略很简单，就是<strong>分段放</strong>。</p>
<ol>
<li>扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步；</li>
<li>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回；</li>
<li>清空join_buffer；</li>
<li>继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第2步。</li>
</ol>
<p>这个流程才体现出了这个算法名字中“Block”的由来，表示“分块去join”。</p>
<p>这时候<strong>由于表t1被分成了两次放入join_buffer中</strong>，<strong>导致表t2会被扫描两次</strong>。虽然分成两次放入join_buffer，但是判断等值条件的次数还是不变的，依然是(88+12)*1000=10万次。</p>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/mysql/mysql_06_08.jpg" alt=""></p>
<h3 id="如何选择驱动表"><a href="#如何选择驱动表" class="headerlink" title="如何选择驱动表"></a>如何选择驱动表</h3><ol>
<li>如果是Index Nested-Loop Join算法，应该选择小表做驱动表；</li>
<li>如果是Block Nested-Loop Join算法：<ul>
<li>在join_buffer_size足够大的时候，是一样的；</li>
<li>在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。</li>
</ul>
</li>
</ol>
<p>总结：<strong>应该使用小表做驱动表。</strong></p>
<p><strong>什么是小表？</strong></p>
<p><strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p>
<p><strong>做表关联的时候，一定要去走被关联表的索引，这才能达到比较好的性能！！！</strong></p>
<h1 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h1><p>在解析和优化阶段, MySQL将生成査询对应的执行计划, MySQL的査询执行引擎则根据这个执行计划来完成整个查询。</p>
<p>查询执行阶段不是那么复杂: MySQL只是简单地根据执行计划给出的指令逐步执行。在根据执行计划逐步执行的过程中,有大量的操作需要通过调用<br>存储引擎实现的接口来完成,这些接口也就是我们称为“ handler api”的接口。</p>
<p>这种简单的接口模式,让 My SQL的存储引擎插件式架构成为可能,但是正<br>如前面的讨论,也给优化器带来了一定的限制。</p>
<h1 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h1><p>如果查询可以被缓存,那么 MySQL在这个阶段也会将结果存放到查询缓存中。</p>
<p>MySQL将结果集返回客户端是一个<strong>增量、逐步返回</strong>的过程。</p>
<p>我们回头看看前面的关联操作,一旦服务器处理完最后一个关联表,<strong>开始生成第一条结果时, MySQL就可以开始向客户端逐步返回结果集了。</strong>这样处理有两个好处:</p>
<ol>
<li><strong>服务器端无须存储太多的结果,也就不会因为要返回太多结果而消耗太多内存</strong></li>
<li>这样的处理也让 MySQL客户端第一时间获得返回的结果。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mysql/" rel="tag"># mysql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql05_%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1/" rel="prev" title="mysql05_锁和事务">
      <i class="fa fa-chevron-left"></i> mysql05_锁和事务
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/08/21/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql07_mysql%E4%BC%98%E5%8C%96/" rel="next" title="mysql07_mysql优化">
      mysql07_mysql优化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一条sql执行过程"><span class="nav-number">1.</span> <span class="nav-text">一条sql执行过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#客户端-服务器通信流程"><span class="nav-number">2.</span> <span class="nav-text">客户端/服务器通信流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查询状态"><span class="nav-number">2.1.</span> <span class="nav-text">查询状态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查询缓存"><span class="nav-number">3.</span> <span class="nav-text">查询缓存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查询优化处理"><span class="nav-number">4.</span> <span class="nav-text">查询优化处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#语法解析器"><span class="nav-number">4.1.</span> <span class="nav-text">语法解析器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预处理器"><span class="nav-number">4.2.</span> <span class="nav-text">预处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查询优化器"><span class="nav-number">4.3.</span> <span class="nav-text">查询优化器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优化策略"><span class="nav-number">4.3.1.</span> <span class="nav-text">优化策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化器能够处理的优化类型"><span class="nav-number">4.3.2.</span> <span class="nav-text">优化器能够处理的优化类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成执行计划"><span class="nav-number">4.3.3.</span> <span class="nav-text">生成执行计划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联查询优化器"><span class="nav-number">4.3.4.</span> <span class="nav-text">关联查询优化器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序"><span class="nav-number">4.3.5.</span> <span class="nav-text">排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL如何关联查询-JOIN原理"><span class="nav-number">4.4.</span> <span class="nav-text">MySQL如何关联查询(JOIN原理)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Index-Nested-Loop-Join"><span class="nav-number">4.4.1.</span> <span class="nav-text">Index Nested-Loop Join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Simple-Nested-Loop-Join-mysql不使用这种方式"><span class="nav-number">4.4.2.</span> <span class="nav-text">Simple Nested-Loop Join(mysql不使用这种方式)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Block-Nested-Loop-Join"><span class="nav-number">4.4.3.</span> <span class="nav-text">Block Nested-Loop Join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何选择驱动表"><span class="nav-number">4.4.4.</span> <span class="nav-text">如何选择驱动表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查询执行引擎"><span class="nav-number">5.</span> <span class="nav-text">查询执行引擎</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#返回结果给客户端"><span class="nav-number">6.</span> <span class="nav-text">返回结果给客户端</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="chenaa"
      src="/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">chenaa</p>
  <div class="site-description" itemprop="description">zZ..zZ..</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenaa</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>

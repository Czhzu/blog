<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="常见应用场景Redis可以做什么？  记录帖子的点赞数、评论数和点击数 (hash)。 记录用户的帖子 ID 列表 (排序)，便于快速显示用户的帖子列表 (zset)。  记录帖子的标题、摘要、作者和封面信息，用于列表页展示 (hash)。  记录帖子的点赞用户 ID 列表，评论 ID 列表，用于显示和去重计数 (zset)。  缓存近期热帖内容 (帖子内容空间占用比较大)，减少数据库压力 (ha">
<meta name="keywords" content="redis">
<meta property="og:type" content="article">
<meta property="og:title" content="redis09_常见问题整理">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;07&#x2F;15&#x2F;%E4%B8%AD%E9%97%B4%E4%BB%B6&#x2F;redis&#x2F;redis09_%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86&#x2F;index.html">
<meta property="og:site_name" content="Chenaa&#39;s Notes">
<meta property="og:description" content="常见应用场景Redis可以做什么？  记录帖子的点赞数、评论数和点击数 (hash)。 记录用户的帖子 ID 列表 (排序)，便于快速显示用户的帖子列表 (zset)。  记录帖子的标题、摘要、作者和封面信息，用于列表页展示 (hash)。  记录帖子的点赞用户 ID 列表，评论 ID 列表，用于显示和去重计数 (zset)。  缓存近期热帖内容 (帖子内容空间占用比较大)，减少数据库压力 (ha">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;redis&#x2F;redis_adventure_01.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;redis&#x2F;redis_adventure_02.png">
<meta property="og:updated_time" content="2020-08-04T13:06:36.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;redis&#x2F;redis_adventure_01.png">

<link rel="canonical" href="http://yoursite.com/2019/07/15/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis09_%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>redis09_常见问题整理 | Chenaa's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chenaa's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">尘事如潮人如水</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/15/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis09_%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="chenaa">
      <meta itemprop="description" content="zZ..zZ..">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenaa's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis09_常见问题整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-15 20:30:00" itemprop="dateCreated datePublished" datetime="2019-07-15T20:30:00+08:00">2019-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-04 21:06:36" itemprop="dateModified" datetime="2020-08-04T21:06:36+08:00">2020-08-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h1><p>Redis可以做什么？</p>
<ol>
<li>记录帖子的点赞数、评论数和点击数 (hash)。</li>
<li>记录用户的帖子 ID 列表 (排序)，便于快速显示用户的帖子列表 (zset)。 </li>
<li>记录帖子的标题、摘要、作者和封面信息，用于列表页展示 (hash)。 </li>
<li>记录帖子的点赞用户 ID 列表，评论 ID 列表，用于显示和去重计数 (zset)。 </li>
<li>缓存近期热帖内容 (帖子内容空间占用比较大)，减少数据库压力 (hash)。 </li>
<li>记录帖子的相关文章 ID，根据内容推荐相关帖子 (list)。</li>
<li>如果帖子 ID 是整数自增的，可以使用 Redis 来分配帖子 ID(计数器)。</li>
<li>收藏集和帖子之间的关系 (zset)。</li>
<li>记录热榜帖子 ID 列表，总热榜和分类热榜 (zset)。</li>
<li>缓存用户行为历史，进行恶意行为过滤 (zset,hash)。<a id="more"></a>

</li>
</ol>
<h1 id="HyperLoglog"><a href="#HyperLoglog" class="headerlink" title="HyperLoglog"></a>HyperLoglog</h1><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是<strong>固定的、并且是很小的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pfadd 增加计数，将用户id加到里面，可以统计某个页面一天被多少用户访问过</span><br><span class="line">pfcount 获取计数</span><br><span class="line">pfmerge 两个pf计数合成一个新的计数</span><br></pre></td></tr></table></figure>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>一般用于UV统计需求。</p>
<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>Redis 官方提供的布隆过滤器到了 Redis 4.0 提供了插件功能之后才正式登场。布隆过滤 器作为一个插件加载到 Redis Server 中，给 Redis 提供了强大的布隆去重功能。</p>
<p>布隆过滤器可以理解为一个不怎么精确的 set 结构，当布隆过滤器说某个值存在时，这个值可能不存在，当它说不存在时，那就肯定不存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bf.add 添加元素</span><br><span class="line">bf.exists 查询元素是否存在</span><br></pre></td></tr></table></figure>
<h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p> <img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/redis/redis_adventure_01.png" alt=""><br> f、g、h为哈希函数。</p>
<p> 向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索 引值然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。</p>
<p> 向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出 来，看看位数组中这几个位置是否都位 1，只要有一个位为 0，那么说明布隆过滤器中这个 key 不存在。<strong>如果都是 1，这并不能说明这个 key 就一定存在，只是极有可能存在</strong>，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。</p>
<p>使用时不要让实际元素远大于初始化大小，当实际元素开始超出初始化大小时，应该对 布隆过滤器进行重建，重新分配一个 size 更大的过滤器，再将所有的历史元素批量 add 进 去 (这就要求我们在其它的存储器中记录所有的历史元素)。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在爬虫系统中，我们需要对 URL 进行去重，已经爬过的网页就可以不用爬了。但是 URL 太多了，几千万几个亿，如果用一个集合装下这些 URL 地址那是非常浪费空间的。这 时候就可以考虑使用布隆过滤器。</p>
<p>布隆过滤器在 NoSQL 数据库领域使用非常广泛，我们平时用到的 HBase、Cassandra 还有 LevelDB、RocksDB 内部都有布隆过滤器结构，布隆过滤器可以显著降低数据库的 IO 请求数量。当用户来查询某个 row 时，可以先通过内存中的布隆过滤器过滤掉大量不存在的 row 请求，然后再去磁盘进行查询。</p>
<p>邮箱系统的垃圾邮件过滤功能也普遍用到了布隆过滤器。</p>
<h1 id="简单限流"><a href="#简单限流" class="headerlink" title="简单限流"></a>简单限流</h1><p>系统要限定用户的某个行为在指定的时间里只能允许发生N次。</p>
<p>用一个 zset 结构记录用户的行为历史，每一个行为都会作为 zset 中的一个 key 保存下来。同一个用户同一种行为用一个 zset 记录。value用行为的时间戳。</p>
<p>每一个行 为到来时，都维护一次时间窗口。将时间窗口外的记录全部清理掉，只保留窗口内的记录。</p>
<p> <img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/redis/redis_adventure_02.png" alt=""></p>
<p><strong>此方案不适合场景</strong><br>比如限定 60s 内操作不得超过 100w 次这样的参数，它是不适合做这样的限流 的，因为会消耗大量的存储空间</p>
<h1 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h1><p>Redis 在 3.2 版本以后增加了地理位置 GEO 模块，意味着我们可以使用 Redis 来实现 摩拜单车「附近的 Mobike」、美团和饿了么「附近的餐馆」这样的功能了。</p>
<p>如果要计算「附近的人」，也就是给定一个元素的坐标，然后计算这个坐标附近 的其它元素，按照距离进行排序，该如何下手？</p>
<h2 id="GeoHash-算法"><a href="#GeoHash-算法" class="headerlink" title="GeoHash 算法"></a>GeoHash 算法</h2><p>GeoHash 算法将二维的经纬度数据映射到一维的整数，这样所有的元素都将在挂载到一 条线上，距离靠近的二维坐标映射到一维后的点之间距离也会很接近。当我们想要计算「附 近的人时」，首先将目标位置映射到这条线上，然后在这个一维的线上获取附近的点就行 了。</p>
<p>设想一个正方形的蛋糕摆在你面前，二刀下去均分 分成四块小正方形，这四个小正方形可以分别标记为 00,01,10,11 四个二进制整数。然后对 每一个小正方形继续用二刀法切割一下，这时每个小小正方形就可以使用 4bit 的二进制整数 予以表示。然后继续切下去，正方形就会越来越小，二进制整数也会越来越长，精确度就会 越来越高。</p>
<p>GeoHash 算法会继续对这个整数做一次 base32 编码 (0-9,a-z 去掉 a,i,l,o 四个字母) 变 成一个字符串。</p>
<p>在 Redis 里面，经纬度使用 52 位的整数进行编码，放进了 zset 里面，zset 的 value 是元素的 key，score 是 GeoHash 的 52 位整数值。</p>
<p>在使用 Redis 进行 Geo 查询时，我们要时刻想到它的内部结构实际上只是一个 zset(skiplist)。通过 zset 的 score 排序就可以得到坐标附近的其它元素 (实际情况要复杂一 些，不过这样理解足够了)，通过将 score 还原成坐标值就可以得到元素的原始坐标。</p>
<h1 id="redis分布式锁实现"><a href="#redis分布式锁实现" class="headerlink" title="redis分布式锁实现"></a>redis分布式锁实现</h1><p>redis分布式锁的实现 主要依赖SET命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line"></span><br><span class="line">EX seconds ： 将键的过期时间设置为 seconds 秒。 </span><br><span class="line">执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。</span><br><span class="line"></span><br><span class="line">PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。 </span><br><span class="line">执行 SET key value PX milliseconds 的效果等同于执行 PSETEX key milliseconds value 。</span><br><span class="line"></span><br><span class="line">NX ： 只在键不存在时， 才对键进行设置操作。 执行 SET key value NX 的效果等同于执行 SETNX key value 。</span><br><span class="line"></span><br><span class="line">XX ： 只在键已经存在时， 才对键进行设置操作。</span><br></pre></td></tr></table></figure>



<h2 id="单机redis"><a href="#单机redis" class="headerlink" title="单机redis"></a>单机redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lock() &#123;</span><br><span class="line">    SET resource_name my_random_value EX timeout NX</span><br><span class="line">&#125;</span><br><span class="line">unlock() &#123;</span><br><span class="line">    EVAL(</span><br><span class="line">        // luascript</span><br><span class="line">        if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span><br><span class="line">            return redis.call(&quot;del&quot;, KEYS[1])</span><br><span class="line">        else</span><br><span class="line">            return 0</span><br><span class="line">        end</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过SET命令 获取锁，key为锁id，value为随机值</li>
<li>释放锁的时候，先判断锁是否为之前获取到的锁，除了检查锁id外 还需要检查锁的随机值。如果都相同，说明这把锁没有其他线程抢占，可以删除释放。</li>
</ol>
<h2 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h2><p>建议直接阅读<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">redis分布式锁官方文档</a></p>
<p>算法很易懂，起始5(<strong>n&gt;=3</strong>)个master节点，分布在不同的机房尽量保证可用性。为了获得锁，client 会进行如下操作：</p>
<ol>
<li>得到当前的时间，微妙单位</li>
<li>尝试顺序地在 5 个实例上申请锁，需要使用相同的key 和 random value。客户端<strong>申请锁的时间</strong>需要小于锁的自动释放时间。如果实例不可用的话(请求超时)，我们需要尽快请求下一个redis实例。</li>
<li>当 client 在大于等于3(<strong>票数过半</strong>)个 master 上成功申请到锁的时候，它会计算申请锁消耗了多少时间(这部分消耗的时间采用获得锁的当下时间减去第一步获得的时间戳得到)，如果锁的持续时长（lock validity time）比流逝的时间多的话，那么锁就真正获取到了。</li>
<li>如果锁申请到了，那么锁真正的<strong>有效时间</strong>为步骤三中计算出来的时间。</li>
<li>如果 client 申请锁失败了，那么它就会在少部分申请成功锁的 master 节点上执行释放锁的操作，重置状态</li>
</ol>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。（黑客可以通过缓存穿透攻击，把db打死）</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>使用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li>
<li>缓存空数据。如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li>
</ol>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>通过加锁或队列的方式保证来保证不会有大量的线程对数据库一次性进行读写。(加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差)</li>
<li>过期时间+随机值，防止一次性大量缓存同时过期</li>
<li>设置过期标志更新缓存 (它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。)</li>
<li></li>
</ol>
<h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>将冷数据提前加载到缓存中，避免用户直接查库。</p>
<h1 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h1><p>惰性更新，先查缓存，查不到缓存去读数据库，并写到缓存。</p>
<h1 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h1><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>比较简单的实现方式是业务系统代码里面加开关，通过配置中心推配置实现降级。</p>
<h1 id="热点数据"><a href="#热点数据" class="headerlink" title="热点数据"></a>热点数据</h1><p>一个key的并发访问量很高</p>
<p>1.本地做缓存<br>2.通过读写分离</p>
<h1 id="一致性哈希和哈希槽区别"><a href="#一致性哈希和哈希槽区别" class="headerlink" title="一致性哈希和哈希槽区别"></a>一致性哈希和哈希槽区别</h1><p>参考redis集群</p>
<h1 id="数据库-缓存读写一致性问题"><a href="#数据库-缓存读写一致性问题" class="headerlink" title="数据库 缓存读写一致性问题"></a>数据库 缓存读写一致性问题</h1><h2 id="双写-cache-aside-pattern"><a href="#双写-cache-aside-pattern" class="headerlink" title="双写 cache aside pattern"></a>双写 cache aside pattern</h2><p>这是最常用最常用的pattern了。<br>其具体逻辑如下：</p>
<p>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。<br>命中：应用程序从cache中取数据，取到后返回。<br>更新：先把数据存到数据库中，成功后，再让缓存失效。</p>
<h2 id="中间件订阅mysql-binlog的方式"><a href="#中间件订阅mysql-binlog的方式" class="headerlink" title="中间件订阅mysql binlog的方式"></a>中间件订阅mysql binlog的方式</h2><h2 id="如果有强一致性要求"><a href="#如果有强一致性要求" class="headerlink" title="如果有强一致性要求"></a>如果有强一致性要求</h2><ol>
<li>需要将操作串行话，使用异步队列或者消息队列来保证</li>
<li>分布式系统可能还需要考虑使用分布式锁。</li>
</ol>
<h1 id="常见问题QA"><a href="#常见问题QA" class="headerlink" title="常见问题QA"></a>常见问题QA</h1><p><strong>项目中缓存是如何使用的？为什么要用缓存？缓存使用不当会造成什么后果？</strong></p>
<p>高性能，高并发。<br>缓存与数据库双写不一致、缓存雪崩、缓存穿透</p>
<p><strong>redis 和 memcached 有什么区别？</strong></p>
<p>redis 相比 memcached 来说，拥有更多的数据结构  </p>
<p><strong>redis 的线程模型是什么？</strong><br>详见事件处理器</p>
<p>*<em>为什么 redis 单线程却能支撑高并发? *</em></p>
<p>单线程避免上下文切换、io多路复用、纯内存操作、C语言实现</p>
<p><strong>redis都有哪些数据类型？分别在哪些场景下使用比较合适呢？</strong><br>详见数据结构</p>
<p><strong>redis的过期策略能介绍一下？要不你再手写一个LRU？</strong><br>详见数据库，过期策略和内存淘汰策略要分清楚</p>
<p><strong>怎么保证redis是高并发以及高可用的？(redis如何通过读写分离来承载读请求QPS超过10万+？)</strong></p>
<p>redis主从架构、读写分离<br>哨兵机制保证高可用</p>
<p><strong>redis主从架构下如何才能做到99.99%的高可用性？</strong><br>哨兵机制</p>
<p><strong>redis哨兵主备切换的数据丢失问题：异步复制、集群脑裂</strong><br>min-slaves选项 参考replication</p>
<p><strong>怎么保证redis挂掉之后再重启数据可以进行恢复？</strong><br>redis数据持久化</p>
<p><strong>你能聊聊redis cluster集群模式的原理吗？</strong><br>见集群篇</p>
<p><strong>redis如何在保持读写分离+高可用的架构下，还能横向扩容支撑1T+海量数据</strong><br>Twemproxy  codis 或者redis cluster</p>
<p><strong>数据分布算法：hash+一致性hash+redis cluster的hash slot<br>redis cluster的核心原理分析</strong><br>见集群篇</p>
<p><strong>你能说说我们一般如何应对缓存雪崩以及穿透问题吗？</strong></p>
<p><strong>如何保证缓存与数据库双写时的数据一致性？</strong></p>
<p><strong>你能说说redis的并发竞争问题该如何解决吗？</strong><br>分布式锁。</p>
<p><strong>你们公司生产环境的redis集群的部署架构是什么样的？</strong></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis08_%E9%9B%86%E7%BE%A4/" rel="prev" title="Redis08_集群">
      <i class="fa fa-chevron-left"></i> Redis08_集群
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/08/01/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101_%E5%88%86%E5%B8%83%E5%BC%8F%E6%A6%82%E5%BF%B5/" rel="next" title="分布式事务01_分布式概念">
      分布式事务01_分布式概念 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#常见应用场景"><span class="nav-number">1.</span> <span class="nav-text">常见应用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HyperLoglog"><span class="nav-number">2.</span> <span class="nav-text">HyperLoglog</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用场景"><span class="nav-number">2.1.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#布隆过滤器"><span class="nav-number">3.</span> <span class="nav-text">布隆过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#布隆过滤器原理"><span class="nav-number">3.1.</span> <span class="nav-text">布隆过滤器原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景"><span class="nav-number">3.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#简单限流"><span class="nav-number">4.</span> <span class="nav-text">简单限流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GeoHash"><span class="nav-number">5.</span> <span class="nav-text">GeoHash</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GeoHash-算法"><span class="nav-number">5.1.</span> <span class="nav-text">GeoHash 算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis分布式锁实现"><span class="nav-number">6.</span> <span class="nav-text">redis分布式锁实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单机redis"><span class="nav-number">6.1.</span> <span class="nav-text">单机redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RedLock"><span class="nav-number">6.2.</span> <span class="nav-text">RedLock</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#缓存穿透"><span class="nav-number">7.</span> <span class="nav-text">缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解决方案"><span class="nav-number">7.1.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#缓存雪崩"><span class="nav-number">8.</span> <span class="nav-text">缓存雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解决方案-1"><span class="nav-number">8.1.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#缓存预热"><span class="nav-number">9.</span> <span class="nav-text">缓存预热</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#缓存更新"><span class="nav-number">10.</span> <span class="nav-text">缓存更新</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#缓存降级"><span class="nav-number">11.</span> <span class="nav-text">缓存降级</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#热点数据"><span class="nav-number">12.</span> <span class="nav-text">热点数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一致性哈希和哈希槽区别"><span class="nav-number">13.</span> <span class="nav-text">一致性哈希和哈希槽区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库-缓存读写一致性问题"><span class="nav-number">14.</span> <span class="nav-text">数据库 缓存读写一致性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#双写-cache-aside-pattern"><span class="nav-number">14.1.</span> <span class="nav-text">双写 cache aside pattern</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中间件订阅mysql-binlog的方式"><span class="nav-number">14.2.</span> <span class="nav-text">中间件订阅mysql binlog的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果有强一致性要求"><span class="nav-number">14.3.</span> <span class="nav-text">如果有强一致性要求</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常见问题QA"><span class="nav-number">15.</span> <span class="nav-text">常见问题QA</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="chenaa"
      src="/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">chenaa</p>
  <div class="site-description" itemprop="description">zZ..zZ..</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenaa</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>

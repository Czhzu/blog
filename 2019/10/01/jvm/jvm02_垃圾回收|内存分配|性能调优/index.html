<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="垃圾回收基础判断对象存活算法(哪些对象需要回收？)引用计数法给对象中添加一个引用计数器，每当一个地方引用它时，计数器的值就+1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。 优点：简单高效 缺点：很难解决出现两个对象之间循环引用的问题。">
<meta name="keywords" content="jvm">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm02_垃圾回收|内存分配|性能调优">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;10&#x2F;01&#x2F;jvm&#x2F;jvm02_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6|%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D|%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98&#x2F;index.html">
<meta property="og:site_name" content="Chenaa&#39;s Notes">
<meta property="og:description" content="垃圾回收基础判断对象存活算法(哪些对象需要回收？)引用计数法给对象中添加一个引用计数器，每当一个地方引用它时，计数器的值就+1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。 优点：简单高效 缺点：很难解决出现两个对象之间循环引用的问题。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;jvm&#x2F;jvm_3-1.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;jvm&#x2F;jvm02_01.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;jvm&#x2F;jvm_3-2.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;jvm&#x2F;jvm_3-3.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;jvm&#x2F;jvm_3-4.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;jvm&#x2F;jvm_3-5.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;jvm&#x2F;jvm_3-6.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;jvm&#x2F;jvm_3-7.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;jvm&#x2F;jvm_3-8.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;jvm&#x2F;jvm_3-9.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;jvm&#x2F;jvm_3-10.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;jvm&#x2F;jvm_3-11.png">
<meta property="og:updated_time" content="2020-07-18T08:40:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;jvm&#x2F;jvm_3-1.png">

<link rel="canonical" href="http://yoursite.com/2019/10/01/jvm/jvm02_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6|%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D|%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>jvm02_垃圾回收|内存分配|性能调优 | Chenaa's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chenaa's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">尘事如潮人如水</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/01/jvm/jvm02_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6|%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D|%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="chenaa">
      <meta itemprop="description" content="zZ..zZ..">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenaa's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          jvm02_垃圾回收|内存分配|性能调优
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-01 20:46:25" itemprop="dateCreated datePublished" datetime="2019-10-01T20:46:25+08:00">2019-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 16:40:15" itemprop="dateModified" datetime="2020-07-18T16:40:15+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="垃圾回收基础"><a href="#垃圾回收基础" class="headerlink" title="垃圾回收基础"></a>垃圾回收基础</h1><h2 id="判断对象存活算法-哪些对象需要回收？"><a href="#判断对象存活算法-哪些对象需要回收？" class="headerlink" title="判断对象存活算法(哪些对象需要回收？)"></a>判断对象存活算法(哪些对象需要回收？)</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每当一个地方引用它时，计数器的值就+1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>优点：简单高效</p>
<p>缺点：很难解决出现两个对象之间循环引用的问题。</p>
<a id="more"></a>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>基本思路：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为<strong>引用链</strong>，当一个对象到GC Roots没有任何引用链相连，此时这个对象时不可用的。</p>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/jvm/jvm_3-1.png" alt=""></p>
<p>可视为GC Roots的对象包括下面几种</p>
<ul>
<li><strong>虚拟机栈（栈帧中的本地变量表）中引用的对象</strong></li>
<li><strong>方法区中的静态属性引用的对象</strong></li>
<li><strong>方法区中常量引用的对象</strong></li>
<li><strong>本地方法栈中JNI（Native方法）引用的对象</strong></li>
<li><strong>Java虚拟机内部的引用</strong>，如基本数据类型对应的Class对象</li>
<li><strong>被synchronized关键字持有的对象</strong></li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul>
<li><strong>强引用</strong>：Object obj = new Object()这类都属于强引用，只要强引用在垃圾收集器就永远不会回收掉被引用的对象。</li>
<li><strong>软引用</strong>：如果内存不足，会被垃圾回收器回收</li>
<li><strong>弱引用</strong>：当垃圾收集器工作时，无轮内存是否充足，都会回收弱引用对象。</li>
<li><strong>虚引用</strong>：也叫幽灵引用或幻影引用，一个对象是否有虚引用的存在，完全不会对其生存时间产生影响。</li>
</ul>
<h2 id="什么时候回收？"><a href="#什么时候回收？" class="headerlink" title="什么时候回收？"></a>什么时候回收？</h2><p>真正要宣告一个对象死亡，<strong>需要经历两次标记过程</strong>。</p>
<ul>
<li><p>如果没有发现对象和GC Roots相连，它会被第一次标记并进行一次筛选</p>
<ul>
<li><p>当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为<strong>没有必要执行</strong>，直接回收</p>
</li>
<li><p>有必要执行时，则会将对象放入一个F-Queue的队列中去执行，随后就会进行第二次的小规模标记，还是不可达就进行回收。</p>
</li>
</ul>
</li>
</ul>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集(通常在方法区手机的“性价比”比较低，<strong>JDK11中的ZGC不支持类卸载。</strong>)</p>
<p>在大量使用反射、动态代理、CGLib等字节码框架，需要使用插件机制、JSP、OSGi等频繁自定义类加载器的场景中，需要垃圾收集器具备类卸载的能力。</p>
<p>永久代的垃圾收集主要回收两部分内容：</p>
<ul>
<li><strong>废弃常量</strong></li>
<li><strong>无用的类</strong>(通过类加载机制，如加载后失效的插件)</li>
</ul>
<p>如何判定无用类：</p>
<ol>
<li>该类所有实例已经被回收。</li>
<li>加载该类的ClassLoader已经被回收(如OSGi、JSP、自己实现的插件)</li>
<li>该类对应的Class对象没有再任何地方被引用，无法再任何地方通过反射访问该类的方法。</li>
</ol>
<p><strong>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</strong></p>
<h2 id="垃圾收集算法-如何回收？"><a href="#垃圾收集算法-如何回收？" class="headerlink" title="垃圾收集算法(如何回收？)"></a>垃圾收集算法(如何回收？)</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前商业虚拟机的垃圾收集，大多遵循了<strong>“分代收集”的理论</strong>进行设计，它建立在两个假说之上:</p>
<ul>
<li>弱分代假说：绝大多数对象都是朝生夕灭</li>
<li>强分代假说：熬过越多垃圾收集过程的对象越难以消亡。</li>
</ul>
<p>将堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。</p>
<ul>
<li><strong>新生代</strong>：每次垃圾收集都有大批对象死去，少量存活，<strong>适合复制算法</strong>。</li>
<li><strong>老年代</strong>：对象存活率高，没有额外空间进行分配担保，<strong>适合使用“标记-清理”或者“标记-整理”算法*</strong>。</li>
</ul>
<h3 id="标记清除算法-Mark-Sweep"><a href="#标记清除算法-Mark-Sweep" class="headerlink" title="标记清除算法(Mark-Sweep)"></a>标记清除算法(Mark-Sweep)</h3><p>最基础的垃圾收集算法，主要不足有两个：</p>
<ol>
<li><strong>效率问题</strong>，标记和清除两个过程的效率都不高。</li>
<li><strong>空间问题</strong> 标记清除之后会产生大量不连续的<strong>空间碎片</strong>，碎片太多会导致jvm创建大对象时，无法找到足够的连续内存而不得不触发另一次垃圾收集动作。</li>
</ol>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/jvm/jvm02_01.png" alt=""></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为解决效率问题，出现了此方法，代价是<strong>将内存缩小到了原来的一半</strong>。此方法一般用来回收新生代。</p>
<p>复制算法缺点：</p>
<ol>
<li>对象存活率较高时会进行较多复制操作，效率变低</li>
<li>浪费50%空间</li>
</ol>
<p>所以这种垃圾收集算法<strong>不适用老年代</strong>。</p>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/jvm/jvm_3-2.png" alt=""></p>
<h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p>算法简介：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>算法缺点：</p>
<ul>
<li>需要移动对象，这是个极为负重的操作</li>
</ul>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/jvm/jvm_3-3.png" alt=""></p>
<h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><p>HotSpot虚拟机的垃圾收集器<br><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/jvm/jvm_3-4.png" alt=""></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial是最基本、发展历史最悠久的收集器，<strong>单线程</strong>的收集器，它进行垃圾收集时，必须暂停其他所有工作线程，直到它运行结束(<strong>Stop The World</strong>)。采用<strong>复制算法</strong>。</p>
<p>优点：<strong>在单核CPU下</strong>，Serial收集器没有线程交互的开销，比其他收集器更高效。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器是<strong>Serial收集器的多线程版本</strong>。</p>
<p>特点：</p>
<ul>
<li>除了Serial收集器外，只有它能与CMS收集器配合工作</li>
<li>多核环境下效率比Serial高，单核下比不过。</li>
<li>默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境下，可以使<strong>用-XX:ParallelGCThreads参数</strong>来限制垃圾回收线程数。</li>
<li>当选择了CMS收集器后，ParNew是默认新生代收集器，也可以<strong>用-XX:+UserParNewGC</strong>强制指定。</li>
</ul>
<p>垃圾收集中<strong>并行</strong>与<strong>并发</strong></p>
<ul>
<li><strong>并行(Parallel)</strong>：多条垃圾收集线程并行工作，此时用户线程仍然处于等待状态。</li>
<li><strong>并发(Concurrent)</strong>：用户线程和垃圾收集线程同时执行，用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</li>
</ul>
<p>ParNew收集器运行示意图<br><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/jvm/jvm_3-5.png" alt=""></p>
<h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器是一个新生代垃圾收集器，也被<strong>称为“吞吐量优先”收集器</strong>。</p>
<p>其目标是达到一个可控制的<strong>吞吐量</strong>。吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p>
<ul>
<li>-XX:MaxGCPauseMillis参数：大于0的毫秒数，收集器将尽可能保证内存回收时间不超过设定值。</li>
<li>-XX:GCTimeRatio参数：大于0小于100的整数，垃圾收集时间占总时间的比率，默认99</li>
<li>-XX:+UseAdaptiveSizePollicy参数：打开这个参数后不需要手工制定新生代大小(-Xmn)、Eden和Survivor区的比例(-XX:ServivorRatio)、晋升老年代对象年龄等细节了，虚拟机会根据系统运行情况动态调整这些参数。这种调节方式称为<strong>GC自适应的调节策略</strong>，这也是和ParNew收集器的重要区别。</li>
</ul>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>Serial Old 收集器是Serial收集器的老年代版本，<strong>单线程</strong>，使用 <strong>标记-整理</strong> 算法。</p>
<p>两大用途如下：</p>
<ol>
<li>在JDK1.5之前与Parallel Scavenge收集器搭配使用。</li>
<li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</li>
</ol>
<p>Serial/Serial Old 收集器运行示意图如下：</p>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/jvm/jvm_3-6.png" alt=""></p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>Parallel Old 收集器 是Parallel Scavenge 收集器的老年代版本，使用<strong>多线程</strong>和 <strong>标记-整理</strong> 算法，JDK1.6之后提供。</p>
<p>在注重吞吐量以及CPU资源敏感的场合，可以优先考虑Parallel Scavenge + Parallel Old 收集器。</p>
<p>Parallel Old/Parallel Scavenge 工作原理如下：</p>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/jvm/jvm_3-7.png" alt=""></p>
<blockquote>
<p>ps: java8 默认是用+UseParallelGC 即Parallel Scavenge + Parallel Old 作为垃圾回收器</p>
</blockquote>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS(Concurrent Mark Sweep)收集器是以获取最短回收停顿时间为目标的收集器。<strong>基于“标记-清除”算法(当full GC一定次数后会用标记整理算法)</strong>。运行步骤如下：</p>
<ol>
<li>初始标记(CMS initial mark，需要Stop The World)：仅标记一下GC Roots能直接关联到的对象，速度很快。</li>
<li>并发标记(CMS concurrent mark)：进行GC Roots Tracking的过程。</li>
<li>重新标记(CMS remark,需要Stop The World)：为了修正并发标记期间，因用户程序继续运转而导致标记产生变动的那一部分对象的标记记录。(时间比初始标记稍长，远比并发标记短)</li>
<li>并发清除(CMS concurrent sweep)</li>
</ol>
<p>整个过程中耗时最长的并发标记和并发清除过程，收集器线程都可以和用户线程一起工作，总体上来说CMS收集器的内存回收过程和用户线程一起并发执行的。</p>
<p>CMS收集器运行示意图：</p>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/jvm/jvm_3-8.png" alt=""></p>
<p>CMS收集器优点如下：</p>
<ul>
<li>并发收集</li>
<li>低停顿</li>
</ul>
<p>缺点如下：</p>
<ul>
<li><strong>CMS收集器对CPU资源非常敏感</strong></li>
<li><strong>CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</strong></li>
<li>基于<strong>标记-清除</strong>算法，产生大量空间碎片。</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><blockquote>
<p>java9中 已经将G1作为默认垃圾收集器，CMS被标记为弃用。</p>
</blockquote>
<p>G1目标就是为了替换掉CMS收集器，G1具备以下特点：</p>
<ol>
<li><strong>并行与并发</strong>：充分利用多CPU、多核环境下的硬件优势，部分其他垃圾收集器原本需要停顿java线程执行的GC动作，G1可以通过并发的方式让Java程序继续运行。</li>
<li><strong>分代收集</strong>：能独立管理整个GC堆，不需要其他垃圾回收器配合</li>
<li><strong>空间整合</strong>：G1整体上看是基于<strong>标记-整理</strong>算法实现的收集器，从局部(两个Region之间)看是基于<strong>复制算法</strong>实现的。</li>
<li><strong>可预测的停顿</strong>：这是G1相比CMS的另一大优势。G1可以建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间片内，消耗在垃圾收集上的时间不超过N毫秒。</li>
</ol>
<p>G1收集器运行示意图：<br><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/jvm/jvm_3-9.png" alt=""></p>
<h2 id="垃圾收集器总结"><a href="#垃圾收集器总结" class="headerlink" title="垃圾收集器总结"></a>垃圾收集器总结</h2><p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/jvm/jvm_3-10.png" alt=""></p>
<p>rawdata 用的垃圾回收器是CMS+ParNewGC ：原因是当时G1还不成熟，java8才出来不久，项目比较急着上线，优先使用成熟的垃圾回收器方案，避免踩坑。</p>
<blockquote>
<p>线上rawdata配置<br>JAVA_OPTS=”-server -Xms4g -Xmx4g -Xss256k -Xmn2g -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSClassUnloadingEnabled -XX:+DisableExplicitGC -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=68 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/gxb/log/gc.log -XX:GCLogFileSize=20M -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=20 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/gxb/dump -Djava.util.Arrays.useLegacyMergeSort=true”</p>
</blockquote>
<h2 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h2><p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/jvm/jvm_3-11.png" alt=""></p>
<ul>
<li>出现<strong>Full GC(System)</strong> 调用了System.gc()</li>
<li>出现<strong>Full</strong> 表示发生了<strong>STW</strong>，并不表示发生在新生代或者老年代</li>
<li><strong>DefNew</strong> “Default New Generation” Serial收集器 新生代</li>
<li><strong>ParNew</strong> “Parallel New Generation” ParNew收集器</li>
<li><strong>PSYoungGen</strong> Parallel Scavenge收集器</li>
</ul>
<h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><p>对象的内存分配，往大方向上讲，就是在堆上分配，对象主要分配在Eden区上。<br>如果开启了本地线程分配缓冲，将按线程优先在TLAB上分配。<br>大对象，可能会直接在老年代中分配。</p>
<h2 id="GC常见名词解释"><a href="#GC常见名词解释" class="headerlink" title="GC常见名词解释"></a>GC常见名词解释</h2><p>针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：</p>
<ul>
<li>Partial GC(部分收集)<ul>
<li>Minor GC/Young GC 新生代收集 回收速度快</li>
<li>Major GC/Old GC 老年代收集,回收速度比MinorGc慢10倍以上</li>
<li>Mixed GC 混合收集，整个新生代和部分老年代，只有G1收集器有这种行为</li>
</ul>
</li>
<li>Full GC 整堆收集，收集整个Java堆和方法区</li>
</ul>
<p>Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。</p>
<p><strong>新生代垃圾回收过程</strong></p>
<ol>
<li>将内存分为大块的Eden空间 和两块较小的 Survivor 空间，每次使用Eden和其中一块Survivor。</li>
<li>当垃圾回收时，将Eden和Survivor中还存活的对象，一次性复制到另一块Survivor，</li>
<li>最后清理掉Eden和使用过的Survivor空间。</li>
<li>如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过<strong>分配担保机制</strong>进入老年代</li>
</ol>
<h2 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h2><p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。</p>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>所谓大对象是指，需要连续内存空间的java对象，典型的大对象就是很长的字符串以及数组。<strong>避免Eden和两个Survivor区之间发生大量内存复制。</strong></p>
<p><strong>如何判断一个对象是大对象？</strong></p>
<ol>
<li>-XX:PretenureSizeThreshold参数可以令内存大于这个值的对象直接在老年代分配，如果这个值设置为3m 必须写成3145728 不能直接写3m。<strong>（对ParallGC无效，只对Serial和ParNew有效）</strong></li>
<li>对象size大于Eden区，比如Eden区大小为8MB，对象需要分配9MB的空间。</li>
</ol>
<h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>如果对象在Eden出生并经过第一次MinorGc后仍然存活，并且被Survivor容纳的话，将被移动到Survivor区，并且对象年龄设置为1，每熬过一次Minor GC 年龄就增加1岁。年龄到一定程度(默认15)会被晋升到老年代中。</p>
<p>-XX:MaxTenuringThreshold 参数可以用来设置对象到老年代的年龄阈值。</p>
<h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>如果在<strong>Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半</strong>，<strong>年龄大于或等于该年龄的对象</strong>可以直接进入老年代，无需到指定年龄。</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>进行Minor GC之前，虚拟机需要先检查老年代的空间是否足够，<strong>虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的空间</strong>或者<strong>历次晋升的平均大小</strong> 就会进行MinorGC，否则进行FullGC。(JDK6 Update24之后)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinorGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _512K = <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        testAllocation();</span></span><br><span class="line"><span class="comment">//        testPretenureSizeThreshold();</span></span><br><span class="line">        testTenuringThreshold();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * -verbose:gc -Xms20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * -verbose:gc -Xms20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">     * -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation;</span><br><span class="line">        allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * -verbose:gc -Xms80M -Xms80M -Xmn40M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">     * -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB * <span class="number">16</span>];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB * <span class="number">16</span>];</span><br><span class="line">        allocation3 = <span class="keyword">null</span>;</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB * <span class="number">16</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h2><p>最简单的分代式GC策略，按HotSpot VM的serial GC的实现来看，触发条件是：</p>
<ul>
<li>young GC：当young gen中的eden区分配满的时候触发。</li>
<li>full GC：<ol>
<li>当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）</li>
<li>要在perm gen(永久代)分配空间但已经没有足够空间时，也要触发一次full GC；</li>
<li>System.gc()、heap dump带GC，默认也是触发full GC。</li>
</ol>
</li>
</ul>
<p>并发GC的触发条件就不太一样。以CMS GC为例，它主要是定时去检查old gen的使用量，当使用量超过了触发比例就会启动一次CMS GC，对old gen做并发收集。</p>
<p><strong>System.gc()详解</strong></p>
<ol>
<li><p>规范层面：<strong>JVM规范没规定实现要使用怎样的自动内存管理；Java的标准库API里System.gc()的规定说它只是一个提示，不保证有什么作用或者何时起作用。</strong>规定说：”Calling the gc method suggests that the Java Virtual Machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse. When control returns from the method call, the Java Virtual Machine has made a best effort to reclaim space from all discarded objects.” 注意“best effort”，其实意思是“尽力呗，不过什么都不干也行”。</p>
</li>
<li><p>实现层面：<strong>HotSpot VM和很多其它JVM一样，其实默认是会在用户调用System.gc()的时候马上执行GC，并且等到GC完成才返回的。只有使用CMS或G1时，配置-XX:+ExplicitGCInvokesConcurrent，调用System.gc()才会在触发了并发GC后就返回。</strong>其中CMS版跟G1版的行为还略微不一样，这里就不展开说了。</p>
</li>
</ol>
<blockquote>
<p>作者：RednaxelaFX<br>链接：<a href="https://www.zhihu.com/question/38551124/answer/77215101" target="_blank" rel="noopener">https://www.zhihu.com/question/38551124/answer/77215101</a><br>来源：知乎<br>R大是真的牛逼</p>
</blockquote>
<h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><ul>
<li>调整内存设置控制垃圾收集频率</li>
<li>选择合适的收集器降低延迟</li>
<li>排查代码问题导致频繁full GC</li>
<li>为避免内存扩展带来的性能浪费,-Xmx -Xms参数保持一致</li>
<li>使用参数-XX:DisableExplicitGC 屏蔽掉代码里的System.gc()</li>
<li>java并发内存越大越好，堆越大(12G),导致Full GC时间过长。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/jvm/" rel="tag"># jvm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/01/jvm/jvm01_jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" rel="prev" title="jvm01_jvm内存结构">
      <i class="fa fa-chevron-left"></i> jvm01_jvm内存结构
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/10/02/jvm/jvm03_CMS&G1%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B/" rel="next" title="jvm03_CMS&G1回收流程">
      jvm03_CMS&G1回收流程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾回收基础"><span class="nav-number">1.</span> <span class="nav-text">垃圾回收基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#判断对象存活算法-哪些对象需要回收？"><span class="nav-number">1.1.</span> <span class="nav-text">判断对象存活算法(哪些对象需要回收？)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数法"><span class="nav-number">1.1.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可达性分析算法"><span class="nav-number">1.1.2.</span> <span class="nav-text">可达性分析算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用类型"><span class="nav-number">1.2.</span> <span class="nav-text">引用类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么时候回收？"><span class="nav-number">1.3.</span> <span class="nav-text">什么时候回收？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回收方法区"><span class="nav-number">1.4.</span> <span class="nav-text">回收方法区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集算法-如何回收？"><span class="nav-number">1.5.</span> <span class="nav-text">垃圾收集算法(如何回收？)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分代收集理论"><span class="nav-number">1.5.1.</span> <span class="nav-text">分代收集理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记清除算法-Mark-Sweep"><span class="nav-number">1.5.2.</span> <span class="nav-text">标记清除算法(Mark-Sweep)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制算法"><span class="nav-number">1.5.3.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-整理算法（Mark-Compact）"><span class="nav-number">1.5.4.</span> <span class="nav-text">标记-整理算法（Mark-Compact）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#经典垃圾收集器"><span class="nav-number">1.6.</span> <span class="nav-text">经典垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial收集器"><span class="nav-number">1.6.1.</span> <span class="nav-text">Serial收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew收集器"><span class="nav-number">1.6.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Scavenge-收集器"><span class="nav-number">1.6.3.</span> <span class="nav-text">Parallel Scavenge 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-Old-收集器"><span class="nav-number">1.6.4.</span> <span class="nav-text">Serial Old 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Old-收集器"><span class="nav-number">1.6.5.</span> <span class="nav-text">Parallel Old 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS收集器"><span class="nav-number">1.6.6.</span> <span class="nav-text">CMS收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1收集器"><span class="nav-number">1.6.7.</span> <span class="nav-text">G1收集器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器总结"><span class="nav-number">1.7.</span> <span class="nav-text">垃圾收集器总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解GC日志"><span class="nav-number">1.8.</span> <span class="nav-text">理解GC日志</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存分配与回收策略"><span class="nav-number">2.</span> <span class="nav-text">内存分配与回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GC常见名词解释"><span class="nav-number">2.1.</span> <span class="nav-text">GC常见名词解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象优先在Eden分配"><span class="nav-number">2.2.</span> <span class="nav-text">对象优先在Eden分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大对象直接进入老年代"><span class="nav-number">2.3.</span> <span class="nav-text">大对象直接进入老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#长期存活的对象将进入老年代"><span class="nav-number">2.4.</span> <span class="nav-text">长期存活的对象将进入老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态对象年龄判定"><span class="nav-number">2.5.</span> <span class="nav-text">动态对象年龄判定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空间分配担保"><span class="nav-number">2.6.</span> <span class="nav-text">空间分配担保</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC触发条件"><span class="nav-number">2.7.</span> <span class="nav-text">GC触发条件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#性能调优"><span class="nav-number">3.</span> <span class="nav-text">性能调优</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="chenaa"
      src="/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">chenaa</p>
  <div class="site-description" itemprop="description">zZ..zZ..</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenaa</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>

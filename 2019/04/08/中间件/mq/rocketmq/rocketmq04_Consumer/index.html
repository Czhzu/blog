<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="RocketMQ消息消费概述消息消费以组的模式开展，一个消费组内可以包含多个消费者，每一个消费组可订阅多个主题，消费组之间有集群模式与广播模式两种消费模式。  集群模式: 主题下的同一条消息只允许被其中一个消费者消费。 广播模式: 主题下的同一条消息将被集群内的所有消费者消费一次。  消息服务器与消费者之间的消息传送也有两种方式：推模式、拉模式。  拉模式 是消费端主动发起拉消息请求 推模式 是消">
<meta name="keywords" content="mq,rocketmq">
<meta property="og:type" content="article">
<meta property="og:title" content="rocketmq04_Consumer">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;04&#x2F;08&#x2F;%E4%B8%AD%E9%97%B4%E4%BB%B6&#x2F;mq&#x2F;rocketmq&#x2F;rocketmq04_Consumer&#x2F;index.html">
<meta property="og:site_name" content="Chenaa&#39;s Notes">
<meta property="og:description" content="RocketMQ消息消费概述消息消费以组的模式开展，一个消费组内可以包含多个消费者，每一个消费组可订阅多个主题，消费组之间有集群模式与广播模式两种消费模式。  集群模式: 主题下的同一条消息只允许被其中一个消费者消费。 广播模式: 主题下的同一条消息将被集群内的所有消费者消费一次。  消息服务器与消费者之间的消息传送也有两种方式：推模式、拉模式。  拉模式 是消费端主动发起拉消息请求 推模式 是消">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;rocketMq&#x2F;Consumer_01.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;rocketMq&#x2F;Consumer_02.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;rocketMq&#x2F;Consumer_03.png">
<meta property="og:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;rocketMq&#x2F;Broker_09.png">
<meta property="og:updated_time" content="2020-04-12T13:11:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;czh-pb-source.oss-cn-hongkong.aliyuncs.com&#x2F;pic&#x2F;rocketMq&#x2F;Consumer_01.png">

<link rel="canonical" href="http://yoursite.com/2019/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/mq/rocketmq/rocketmq04_Consumer/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>rocketmq04_Consumer | Chenaa's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chenaa's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">尘事如潮人如水</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/mq/rocketmq/rocketmq04_Consumer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="chenaa">
      <meta itemprop="description" content="zZ..zZ..">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenaa's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          rocketmq04_Consumer
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-08 20:00:00" itemprop="dateCreated datePublished" datetime="2019-04-08T20:00:00+08:00">2019-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 21:11:27" itemprop="dateModified" datetime="2020-04-12T21:11:27+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mq/" itemprop="url" rel="index"><span itemprop="name">mq</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mq/rocketmq/" itemprop="url" rel="index"><span itemprop="name">rocketmq</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="RocketMQ消息消费概述"><a href="#RocketMQ消息消费概述" class="headerlink" title="RocketMQ消息消费概述"></a>RocketMQ消息消费概述</h1><p>消息消费以组的模式开展，一个消费组内可以包含多个消费者，每一个消费组可订阅多个主题，消费组之间有<strong>集群模式</strong>与<strong>广播模式</strong>两种消费模式。</p>
<ul>
<li><strong>集群模式</strong>: 主题下的同一条消息只允许被其中一个消费者消费。</li>
<li><strong>广播模式</strong>: 主题下的同一条消息将被集群内的所有消费者消费一次。</li>
</ul>
<p>消息服务器与消费者之间的消息传送也有两种方式：推模式、拉模式。</p>
<ul>
<li><strong>拉模式</strong> 是消费端主动发起拉消息请求</li>
<li><strong>推模式</strong> 是消息到达消息服务器后，推送给消息消费者。(RocketMQ消息推模式的实现基于拉模式，在拉模式上包装一层，一个拉取任务完成后开始下一个拉取任务。)</li>
</ul>
<a id="more"></a>

<h1 id="消息消费流程"><a href="#消息消费流程" class="headerlink" title="消息消费流程"></a>消息消费流程</h1><h2 id="消息拉取"><a href="#消息拉取" class="headerlink" title="消息拉取"></a>消息拉取</h2><h3 id="PullMessageService实现"><a href="#PullMessageService实现" class="headerlink" title="PullMessageService实现"></a>PullMessageService实现</h3><p><strong>PullMessageService在初始化后会调用start方法，一直不断的去broker拉取消息。</strong></p>
<p>PullMessageService从消息服务器默认每次拉取32条消息，按消息的队列偏移量顺序存放在ProcessQueue中，PullMessageService然后将消息提交到消费者消费线程池，消息成功消费后从ProcessQueue中移除。</p>
<p> <img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/rocketMq/Consumer_01.png" alt=""></p>
<h2 id="消息队列负载与重新分布机制"><a href="#消息队列负载与重新分布机制" class="headerlink" title="消息队列负载与重新分布机制"></a>消息队列负载与重新分布机制</h2><p>RocketMQ消息队列重新分布是由RebalanceService线程来实现的。一个MQClientInstance持有一个RebalanceService实现，并随着MQC!ientlnstance的启动而启动。</p>
<p>RebalanceService线程默认每隔20s执行一次mqClientFactory.doRebalance（）方法，可以使用－Drocketmq.client.r巳balance.waitlnterval=interval来改变默认值。</p>
<p>MQClientlinstance遍历已注册的消费者，对消费者执行doRebalance（）方法。</p>
<p>每个DefaultMQPushConsumerlmpl都持有一个单独的Rebalancelmpl对象，该方法主要是遍历订阅信息对每个主题的队列进行重新负载。</p>
<p>主要进行负载均衡的方法为<br>org.apache.rocketmq.client.impl.consumer.RebalanceImpl#rebalanceByTopic</p>
<h3 id="负载均衡的实现"><a href="#负载均衡的实现" class="headerlink" title="负载均衡的实现"></a>负载均衡的实现</h3><p><strong>前提</strong><br>消费者在启动的时候会向MQClientlnstance中注册消费者，然后MQClientlnstance会向所有的Broker发送心跳包，心跳包中包含MQClientlnstance的消费者信息。</p>
<p>RocketMQ用一个叫ClientID的概念，来唯一标记一个客户端实例，一个客户端实例对于Broker而言会开辟一个Netty的客户端实例。 而ClientID是由ClientIP+InstanceName构成，故如果一个进程中多个实例（无论Producer还是Consumer）ClientIP和InstanceName都一样,他们将公用一个内部实例（同一套网络连接，线程资源等）</p>
<p>此外，此ClientID在对于Consumer负载均衡的时候起到唯一标识的作用，一旦多个实例（无论不同进程、不通机器、还是同一进程）的多个Consumer实例有一样的ClientID，负载均衡的时候必然RocketMQ任然会把两个实例当作一个client（因为同样一个clientID）。 </p>
<p>ClientConfig中可以看到CID的生成方式。</p>
<p>消息队列负载机制遵循一个通用的思想：<strong>一个消息队列同一时间只允许被一个消费者消费，一个消费者可以消费多个消息队列</strong><br>同一个消息队列只会分配给一个消费者， 故如果消费者个数大于消息队列数量， 则有些消费者无法消费消息。</p>
<ol>
<li>从主题订阅信息缓存表中获取主题的队列信息；发送请求从Broker中该消费组内当前所有的消费者客户端ID(随机选择一台Broker)</li>
<li><strong>对cidAll(所有的消费者id)和mqAll(所有的消息队列)进行排序。</strong></li>
<li>使用负载均衡策略进行分配，有6种负载策略(原来是5种，最新版本源码中有6种，参考rebalance包)<ul>
<li>AllocateMessageQueueAveragely 平均分配</li>
<li>AllocateMessageQueueAveragelyByCircle 平均轮询分配</li>
<li>AllocateMessageQueueConsistentHash 一致性哈希</li>
<li>AllocateMessageQueueByConfig 根据配置指定消费</li>
<li>AllocateMessageQueueByMachineRoom 根据Broker部署机房名</li>
<li>AllocateMachineRoomNearby  根据最近的机房<br>对比消息队列是否发生变化，主要思路是遍历当前负载队列集合，如果队列不在新分配队列集合中，需要将该队列停止消费并保存消费进度；遍历已分配的队列，如果队列不在队列负载表中（processQueueTable）则需要创建该队列拉取任务PullRequest，然后添加到PullMessageService线程的pullRequestQueue中，PullMessageService才会继续拉取任务。</li>
</ul>
</li>
<li>分配到队列，开始消费数据</li>
</ol>
<p><strong>由于每次进行队列重新负载时会从Broker实时查询出当前消费组内所有消费者，并且对消息队列、消费者列表进行排序，这样新加入的消费者就会在队列重新分布时分配到消费队列从而消费消息。</strong></p>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/rocketMq/Consumer_02.png" alt=""></p>
<h2 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h2><p>如果是广播模式，业务方返回RECONSUME_LATER，消息并不会重新被消费，只是以警告级别输出到日志文件。</p>
<p>如果是集群模式，只有在业务方返回RECONSUME_LATER时，该批消息都需要发ACK消息，如果消息发送ACK失败，则直接将本批ACK消费发送失败的消息再次封装为ConsumeRequest，然后延迟5s后重新消费。如果ACK消息发送成功，则该消息会延迟消费。<strong>消费成功的消息不会进行ACK的返回，直接通过消费进度同步到Broker上面。</strong></p>
<p>在执行消息消费的前后，都要验证验证一下ProcessQueue的isDroped状态值，如果设置为tru，将不进行处理，如果由于由新的消费者加入或原先的消费者出现若机导致原先分给消费者的队列在负载之后分配给别的消费者，那么在应用程序的角度来看的话，消息会被重复消费。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(!isDroped)&#123;</span><br><span class="line">	do Consume</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(!isDroped)&#123;</span><br><span class="line">	submit result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="消息消费ACK机制-amp-消息重试"><a href="#消息消费ACK机制-amp-消息重试" class="headerlink" title="消息消费ACK机制&amp;消息重试"></a>消息消费ACK机制&amp;消息重试</h2><p>官方文档引述</p>
<blockquote>
<p>Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p>
<ul>
<li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。</li>
<li>由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。</li>
</ul>
<p>RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p>
</blockquote>
<p>Consumer启动时会自动订阅<strong>重试主题消息</strong>。 </p>
<p>RocketMQ 消息重试是以消费组为单位，而不是主题，消息重试主题名为<strong>%RETRY%＋消费组名</strong>。 消费者在启动的时候会自动订阅该主题，参与该主题的消息队列负载。</p>
<p>只有当消费模式为MessageModel.CLUSTERING(集群模式) 时，Broker才会自动进行重试，<strong>对于广播消息是不会重试的。</strong></p>
<p>集群消费模式下，当消息消费失败，RocketMQ会通过消息重试机制重新投递消息，努力使该消息消费成功。</p>
<p>消费者消费消息以后，只有返回ConsumeConcurrentlyStatus 消费成功状态，才不会进入消息重试，否则Broker会对消息进行重新投递。</p>
<p>broker会根据返回的ACK数据进行如下操作</p>
<ol>
<li>创建重试主题，重试主题名称：<strong>%RETRY%＋消费组名称</strong>，并从重试队列中随机选择一个队列，并构建TopicConfig主题配置信息。</li>
<li>设置消息重试次数，如果消息已重试次数超过maxReconsumeTimes，再次改变newTopic主题为DLQ（”%DLQ%”），该主题的权限为只写，说明消息一旦进入到DLQ队列中，RocketMQ将不负责再次调度进行消费了，需要人工干预。(死信队列)</li>
<li>根据原先的消息创建一个新的消息对象，<strong>重试消息会拥有自己的唯一消息ID(msgld）并存人到commitlog文件中，并不会去更新原先消息，而是会将原先的主题、消息ID存入消息的属性中，主题名称为重试主题，其他属性与原先消息保持相同</strong></li>
<li>在存入Commitlog文件之前，如果消息的延迟级别delayTimeLevel大于0，替换消息的主题与队列为定时任务主题“SCHEDULE_TOPIC_XXXX”，队列ID为延迟级别减1。再次将消息主题、队列存入消息的属性中，键分别为：PROPERTYREALTOPIC、PROPERTY_REALQUEUE_ID</li>
<li>ACK 消息存入 CommitLog 文件后 ，将依托 RocketMQ 定时消息机制在延迟时间到期 后再次将消息拉取，提交消费线程池</li>
</ol>
<h2 id="消费进度管理"><a href="#消费进度管理" class="headerlink" title="消费进度管理"></a>消费进度管理</h2><p>广播模式：同一个消费组的所有消息消费者都需要消费主题下的所有消息，也就是同组内的消费者的消息消费行为是对立的，互相不影响，故消息进度需要独立存储，最理想的存储地方应该是与消费者绑定。</p>
<p><strong>广播模式消息消费进度存储在消费者本地</strong>，其实现类LocalFileOffsetStore。</p>
<p>集群模式：同一个消费组内的所有消息消费者共享消息主题下的所有消息，同一条消息（同一个消息消费队列）在同一时间只会被消费组内的一个消费者消费，并且随着消费队列的动态变化重新负载，所以消费进度需要保存在一个每个消费者都能访问到的地方。</p>
<p><strong>集群模式消息进度存储文件存放在消息服务端 Broker</strong>，RemoteBrokerOffsetStore。</p>
<p>消费者在消费完数据后，调用processConsumeResult方法 updateOffset方法更新内存中的offset， persist方法会持久化offset到本地或者RemoteBroker。消费者在处理完一个消费任务以后都会用当前队列的最小偏移量来更新消费进度(内存中更新,不做持久化)。</p>
<p>消费者会在下面两种情况下做持久化</p>
<ol>
<li>负载均衡，消费者移除部分queue的时候，见removeUnnecessaryMessageQueue()方法</li>
<li>MQClientInstance  startScheduledTask()方法中 定时调用persistAllConsumerOffset()方法 默认5秒同步一次。</li>
</ol>
<p>Broker 端默认 10s 持久化一次消息进度。</p>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/rocketMq/Consumer_03.png" alt=""></p>
<h1 id="定时消息-amp-消息重试"><a href="#定时消息-amp-消息重试" class="headerlink" title="定时消息&amp;消息重试"></a>定时消息&amp;消息重试</h1><blockquote>
<p>定时消息是指消息发到 Broker 后，不能立刻被 Consumer 消费，要到特定的时间点或者等待特定的时间后才能被消费。</p>
</blockquote>
<h2 id="延迟级别"><a href="#延迟级别" class="headerlink" title="延迟级别"></a>延迟级别</h2><p><strong>RocketMQ只支持特定级别的延迟消息</strong></p>
<p>要支持任意时间精度的定时调度，不可避免地需要在Broker层做消息排序，再加上持久化方面的考量，将不可避免地带来具大的性能消耗。</p>
<p>定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。<br>broker有配置项messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18个level。可以配置自定义messageDelayLevel。<strong>注意，messageDelayLevel是broker的属性，不属于某个topic。</strong>发消息时，设置delayLevel等级即可：msg.setDelayLevel(level)。level有以下三种情况：</p>
<ul>
<li>level == 0，消息为非延迟消息</li>
<li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1s</li>
<li>level &gt; maxLevel，则level== maxLevel，例如level==20，延迟2h</li>
</ul>
<blockquote>
<p>ps :超过18以后，也只会取前18个level。<br>18个level可以自定义，支持 s m h d，最多到天</p>
</blockquote>
<p>定时消息会暂存在名为<strong>SCHEDULE_TOPIC_XXXX</strong>(XXX不是占位符。。。真的就叫XXX)的topic中。</p>
<p><strong>根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。</strong></p>
<p>broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p>
<p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// MessageStoreConfig.java</span><br><span class="line">private String messageDelayLevel = &quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//ScheduleMessageService.java</span></span><br><span class="line"><span class="comment">//解析延迟级别</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseDelayLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       HashMap&lt;String, Long&gt; timeUnitTable = <span class="keyword">new</span> HashMap&lt;String, Long&gt;();</span><br><span class="line">       timeUnitTable.put(<span class="string">"s"</span>, <span class="number">1000L</span>);</span><br><span class="line">       timeUnitTable.put(<span class="string">"m"</span>, <span class="number">1000L</span> * <span class="number">60</span>);</span><br><span class="line">       timeUnitTable.put(<span class="string">"h"</span>, <span class="number">1000L</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">       timeUnitTable.put(<span class="string">"d"</span>, <span class="number">1000L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">       String levelString = <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getMessageDelayLevel();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String[] levelArray = levelString.split(<span class="string">" "</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelArray.length; i++) &#123;</span><br><span class="line">               String value = levelArray[i];</span><br><span class="line">               String ch = value.substring(value.length() - <span class="number">1</span>);</span><br><span class="line">               Long tu = timeUnitTable.get(ch);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">int</span> level = i + <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span> (level &gt; <span class="keyword">this</span>.maxDelayLevel) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.maxDelayLevel = level;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">long</span> num = Long.parseLong(value.substring(<span class="number">0</span>, value.length() - <span class="number">1</span>));</span><br><span class="line">               <span class="keyword">long</span> delayTimeMillis = tu * num;</span><br><span class="line">               <span class="keyword">this</span>.delayLevelTable.put(level, delayTimeMillis);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">"parseDelayLevel exception"</span>, e);</span><br><span class="line">           log.info(<span class="string">"levelString String = &#123;&#125;"</span>, levelString);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="producer发送定时消息"><a href="#producer发送定时消息" class="headerlink" title="producer发送定时消息"></a>producer发送定时消息</h2><p>设置消息延迟级别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message msg = new Message(...);</span><br><span class="line">msg.setDelayTimeLevel(level);</span><br></pre></td></tr></table></figure>

<h2 id="broker存储定时消息"><a href="#broker存储定时消息" class="headerlink" title="broker存储定时消息"></a>broker存储定时消息</h2><p>定时消息会暂存在名为<strong>SCHEDULE_TOPIC_XXXX</strong>(XXX不是占位符。。。真的就叫XXX)的topic中。</p>
<p><strong>根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> 1: //【CommitLog.java】</span><br><span class="line"> 2: /**</span><br><span class="line"> 3:  * 添加消息，返回消息结果</span><br><span class="line"> 4:  *</span><br><span class="line"> 5:  * @param msg 消息</span><br><span class="line"> 6:  * @return 结果</span><br><span class="line"> 7:  */</span><br><span class="line"> 8: public PutMessageResult putMessage(final MessageExtBrokerInner msg) &#123;</span><br><span class="line"> 9:     // ....(省略代码) </span><br><span class="line">10: </span><br><span class="line">11:     // 定时消息处理</span><br><span class="line">12:     final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">13:     if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE//</span><br><span class="line">14:         || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">15:         // Delay Delivery</span><br><span class="line">16:         if (msg.getDelayTimeLevel() &gt; 0) &#123;</span><br><span class="line">17:             if (msg.getDelayTimeLevel() &gt; this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">18:                 msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">19:             &#125;</span><br><span class="line">20: </span><br><span class="line">21:             // 存储消息时，延迟消息进入 `Topic` 为 `SCHEDULE_TOPIC_XXXX` 。</span><br><span class="line">22:             topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">23: </span><br><span class="line">24:             // 延迟级别 与 消息队列编号 做固定映射</span><br><span class="line">25:             queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line">26: </span><br><span class="line">27:             // Backup real topic, queueId</span><br><span class="line">28:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">29:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">30:             msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">31: </span><br><span class="line">32:             msg.setTopic(topic);</span><br><span class="line">33:             msg.setQueueId(queueId);</span><br><span class="line">34:         &#125;</span><br><span class="line">35:     &#125;</span><br><span class="line">36: </span><br><span class="line">37:     // ....(省略代码) </span><br><span class="line">38: &#125;</span><br><span class="line">39: </span><br><span class="line">40: //【ScheduleMessageService.java】</span><br><span class="line">41: /**</span><br><span class="line">42:  * 根据 延迟级别 计算 消息队列编号</span><br><span class="line">43:  * QueueId = DelayLevel - 1</span><br><span class="line">44:  *</span><br><span class="line">45:  * @param delayLevel 延迟级别</span><br><span class="line">46:  * @return 消息队列编号</span><br><span class="line">47:  */</span><br><span class="line">48: public static int delayLevel2QueueId(final int delayLevel) &#123;</span><br><span class="line">49:     return delayLevel - 1;</span><br><span class="line">50: &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Broker-发送定时消息"><a href="#Broker-发送定时消息" class="headerlink" title="Broker 发送定时消息"></a>Broker 发送定时消息</h2><p>对 SCHEDULE_TOPIC_XXXX 每条消费队列对应单独一个定时任务进行轮询，发送到达投递时间【计划消费时间】 的消息。 具体实现见ScheduleMessageService.java</p>
<p><img src="https://czh-pb-source.oss-cn-hongkong.aliyuncs.com/pic/rocketMq/Broker_09.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">  1: /**</span><br><span class="line">  2:  *  发送（投递）延迟消息定时任务</span><br><span class="line">  3:  */</span><br><span class="line">  4: class DeliverDelayedMessageTimerTask extends TimerTask &#123;</span><br><span class="line">  5:     /**</span><br><span class="line">  6:      * 延迟级别</span><br><span class="line">  7:      */</span><br><span class="line">  8:     private final int delayLevel;</span><br><span class="line">  9:     /**</span><br><span class="line"> 10:      * 位置</span><br><span class="line"> 11:      */</span><br><span class="line"> 12:     private final long offset;</span><br><span class="line"> 13: </span><br><span class="line"> 14:     public DeliverDelayedMessageTimerTask(int delayLevel, long offset) &#123;</span><br><span class="line"> 15:         this.delayLevel = delayLevel;</span><br><span class="line"> 16:         this.offset = offset;</span><br><span class="line"> 17:     &#125;</span><br><span class="line"> 18: </span><br><span class="line"> 19:     @Override</span><br><span class="line"> 20:     public void run() &#123;</span><br><span class="line"> 21:         try &#123;</span><br><span class="line"> 22:             this.executeOnTimeup();</span><br><span class="line"> 23:         &#125; catch (Exception e) &#123;</span><br><span class="line"> 24:             // XXX: warn and notify me</span><br><span class="line"> 25:             log.error(&quot;ScheduleMessageService, executeOnTimeup exception&quot;, e);</span><br><span class="line"> 26:             ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(</span><br><span class="line"> 27:                 this.delayLevel, this.offset), DELAY_FOR_A_PERIOD);</span><br><span class="line"> 28:         &#125;</span><br><span class="line"> 29:     &#125;</span><br><span class="line"> 30: </span><br><span class="line"> 31:     /**</span><br><span class="line"> 32:      * 纠正可投递时间。</span><br><span class="line"> 33:      * 因为发送级别对应的发送间隔可以调整，如果超过当前间隔，则修正成当前配置，避免后面的消息无法发送。</span><br><span class="line"> 34:      *</span><br><span class="line"> 35:      * @param now 当前时间</span><br><span class="line"> 36:      * @param deliverTimestamp 投递时间</span><br><span class="line"> 37:      * @return 纠正结果</span><br><span class="line"> 38:      */</span><br><span class="line"> 39:     private long correctDeliverTimestamp(final long now, final long deliverTimestamp) &#123;</span><br><span class="line"> 40:         long result = deliverTimestamp;</span><br><span class="line"> 41: </span><br><span class="line"> 42:         long maxTimestamp = now + ScheduleMessageService.this.delayLevelTable.get(this.delayLevel);</span><br><span class="line"> 43:         if (deliverTimestamp &gt; maxTimestamp) &#123;</span><br><span class="line"> 44:             result = now;</span><br><span class="line"> 45:         &#125;</span><br><span class="line"> 46: </span><br><span class="line"> 47:         return result;</span><br><span class="line"> 48:     &#125;</span><br><span class="line"> 49: </span><br><span class="line"> 50:     public void executeOnTimeup() &#123;</span><br><span class="line"> 51:         ConsumeQueue cq = ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,  delayLevel2QueueId(delayLevel));</span><br><span class="line"> 52: </span><br><span class="line"> 53:         long failScheduleOffset = offset;</span><br><span class="line"> 54: </span><br><span class="line"> 55:         if (cq != null) &#123;</span><br><span class="line"> 56:             SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset);</span><br><span class="line"> 57:             if (bufferCQ != null) &#123;</span><br><span class="line"> 58:                 try &#123;</span><br><span class="line"> 59:                     long nextOffset = offset;</span><br><span class="line"> 60:                     int i = 0;</span><br><span class="line"> 61:                     for (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line"> 62:                         long offsetPy = bufferCQ.getByteBuffer().getLong();</span><br><span class="line"> 63:                         int sizePy = bufferCQ.getByteBuffer().getInt();</span><br><span class="line"> 64:                         long tagsCode = bufferCQ.getByteBuffer().getLong();</span><br><span class="line"> 65: </span><br><span class="line"> 66:                         long now = System.currentTimeMillis();</span><br><span class="line"> 67:                         long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode);</span><br><span class="line"> 68: </span><br><span class="line"> 69:                         nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line"> 70: </span><br><span class="line"> 71:                         long countdown = deliverTimestamp - now;</span><br><span class="line"> 72: </span><br><span class="line"> 73:                         if (countdown &lt;= 0) &#123; // 消息到达可发送时间</span><br><span class="line"> 74:                             MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy);</span><br><span class="line"> 75:                             if (msgExt != null) &#123;</span><br><span class="line"> 76:                                 try &#123;</span><br><span class="line"> 77:                                     // 发送消息</span><br><span class="line"> 78:                                     MessageExtBrokerInner msgInner = this.messageTimeup(msgExt);</span><br><span class="line"> 79:                                     PutMessageResult putMessageResult = ScheduleMessageService.this.defaultMessageStore.putMessage(msgInner);</span><br><span class="line"> 80:                                     if (putMessageResult != null &amp;&amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) &#123; // 发送成功</span><br><span class="line"> 81:                                         continue;</span><br><span class="line"> 82:                                     &#125; else &#123; // 发送失败</span><br><span class="line"> 83:                                         // XXX: warn and notify me</span><br><span class="line"> 84:                                         log.error(&quot;ScheduleMessageService, a message time up, but reput it failed, topic: &#123;&#125; msgId &#123;&#125;&quot;, msgExt.getTopic(), msgExt.getMsgId());</span><br><span class="line"> 85: </span><br><span class="line"> 86:                                         // 安排下一次任务</span><br><span class="line"> 87:                                         ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), DELAY_FOR_A_PERIOD);</span><br><span class="line"> 88: </span><br><span class="line"> 89:                                         // 更新进度</span><br><span class="line"> 90:                                         ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);</span><br><span class="line"> 91:                                         return;</span><br><span class="line"> 92:                                     &#125;</span><br><span class="line"> 93:                                 &#125; catch (Exception e) &#123;</span><br><span class="line"> 94:                                     // XXX: warn and notify me</span><br><span class="line"> 95:                                     log.error(&quot;ScheduleMessageService, messageTimeup execute error, drop it. msgExt=&quot;</span><br><span class="line"> 96:                                             + msgExt + &quot;, nextOffset=&quot; + nextOffset + &quot;,offsetPy=&quot; + offsetPy + &quot;,sizePy=&quot; + sizePy, e);</span><br><span class="line"> 97:                                 &#125;</span><br><span class="line"> 98:                             &#125;</span><br><span class="line"> 99:                         &#125; else &#123;</span><br><span class="line">100:                             // 安排下一次任务</span><br><span class="line">101:                             ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), countdown);</span><br><span class="line">102: </span><br><span class="line">103:                             // 更新进度</span><br><span class="line">104:                             ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);</span><br><span class="line">105:                             return;</span><br><span class="line">106:                         &#125;</span><br><span class="line">107:                     &#125; // end of for</span><br><span class="line">108: </span><br><span class="line">109:                     nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">110: </span><br><span class="line">111:                     // 安排下一次任务</span><br><span class="line">112:                     ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), DELAY_FOR_A_WHILE);</span><br><span class="line">113: </span><br><span class="line">114:                     // 更新进度</span><br><span class="line">115:                     ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);</span><br><span class="line">116:                     return;</span><br><span class="line">117:                 &#125; finally &#123;</span><br><span class="line">118:                     bufferCQ.release();</span><br><span class="line">119:                 &#125;</span><br><span class="line">120:             &#125; // end of if (bufferCQ != null)</span><br><span class="line">121:             else &#123; // 消费队列已经被删除部分，跳转到最小的消费进度</span><br><span class="line">122:                 long cqMinOffset = cq.getMinOffsetInQueue();</span><br><span class="line">123:                 if (offset &lt; cqMinOffset) &#123;</span><br><span class="line">124:                     failScheduleOffset = cqMinOffset;</span><br><span class="line">125:                     log.error(&quot;schedule CQ offset invalid. offset=&quot; + offset + &quot;, cqMinOffset=&quot;</span><br><span class="line">126:                         + cqMinOffset + &quot;, queueId=&quot; + cq.getQueueId());</span><br><span class="line">127:                 &#125;</span><br><span class="line">128:             &#125;</span><br><span class="line">129:         &#125; // end of if (cq != null)</span><br><span class="line">130: </span><br><span class="line">131:         ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, failScheduleOffset), DELAY_FOR_A_WHILE);</span><br><span class="line">132:     &#125;</span><br><span class="line">133: </span><br><span class="line">134:     /**</span><br><span class="line">135:      * 设置消息内容</span><br><span class="line">136:      *</span><br><span class="line">137:      * @param msgExt 消息</span><br><span class="line">138:      * @return 消息</span><br><span class="line">139:      */</span><br><span class="line">140:     private MessageExtBrokerInner messageTimeup(MessageExt msgExt) &#123;</span><br><span class="line">141:         MessageExtBrokerInner msgInner = new MessageExtBrokerInner();</span><br><span class="line">142:         msgInner.setBody(msgExt.getBody());</span><br><span class="line">143:         msgInner.setFlag(msgExt.getFlag());</span><br><span class="line">144:         MessageAccessor.setProperties(msgInner, msgExt.getProperties());</span><br><span class="line">145: </span><br><span class="line">146:         TopicFilterType topicFilterType = MessageExt.parseTopicFilterType(msgInner.getSysFlag());</span><br><span class="line">147:         long tagsCodeValue =</span><br><span class="line">148:             MessageExtBrokerInner.tagsString2tagsCode(topicFilterType, msgInner.getTags());</span><br><span class="line">149:         msgInner.setTagsCode(tagsCodeValue);</span><br><span class="line">150:         msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</span><br><span class="line">151: </span><br><span class="line">152:         msgInner.setSysFlag(msgExt.getSysFlag());</span><br><span class="line">153:         msgInner.setBornTimestamp(msgExt.getBornTimestamp());</span><br><span class="line">154:         msgInner.setBornHost(msgExt.getBornHost());</span><br><span class="line">155:         msgInner.setStoreHost(msgExt.getStoreHost());</span><br><span class="line">156:         msgInner.setReconsumeTimes(msgExt.getReconsumeTimes());</span><br><span class="line">157: </span><br><span class="line">158:         msgInner.setWaitStoreMsgOK(false);</span><br><span class="line">159:         MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_DELAY_TIME_LEVEL);</span><br><span class="line">160: </span><br><span class="line">161:         msgInner.setTopic(msgInner.getProperty(MessageConst.PROPERTY_REAL_TOPIC));</span><br><span class="line">162: </span><br><span class="line">163:         String queueIdStr = msgInner.getProperty(MessageConst.PROPERTY_REAL_QUEUE_ID);</span><br><span class="line">164:         int queueId = Integer.parseInt(queueIdStr);</span><br><span class="line">165:         msgInner.setQueueId(queueId);</span><br><span class="line">166: </span><br><span class="line">167:         return msgInner;</span><br><span class="line">168:     &#125;</span><br><span class="line">169: &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Broker-持久化定时发送进度"><a href="#Broker-持久化定时发送进度" class="headerlink" title="Broker 持久化定时发送进度"></a>Broker 持久化定时发送进度</h2><p>定时消息发送进度存储在文件(../config/delayOffset.json)里</p>
<p> 每 10s 定时持久化发送进度。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  1: // 【ScheduleMessageService.java】</span><br><span class="line"> 2: /**</span><br><span class="line"> 3: public void start() &#123;</span><br><span class="line"> 4:     // 定时发送消息</span><br><span class="line"> 5:     for (Map.Entry&lt;Integer, Long&gt; entry : this.delayLevelTable.entrySet()) &#123;</span><br><span class="line"> 6:         Integer level = entry.getKey();</span><br><span class="line"> 7:         Long timeDelay = entry.getValue();</span><br><span class="line"> 8:         Long offset = this.offsetTable.get(level);</span><br><span class="line"> 9:         if (null == offset) &#123;</span><br><span class="line">10:             offset = 0L;</span><br><span class="line">11:         &#125;</span><br><span class="line">12: </span><br><span class="line">13:         if (timeDelay != null) &#123;</span><br><span class="line">14:             this.timer.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);</span><br><span class="line">15:         &#125;</span><br><span class="line">16:     &#125;</span><br><span class="line">17: </span><br><span class="line">18:     // 定时持久化发送进度</span><br><span class="line">19:     this.timer.scheduleAtFixedRate(new TimerTask() &#123;</span><br><span class="line">20: </span><br><span class="line">21:         @Override</span><br><span class="line">22:         public void run() &#123;</span><br><span class="line">23:             try &#123;</span><br><span class="line">24:                 ScheduleMessageService.this.persist();</span><br><span class="line">25:             &#125; catch (Exception e) &#123;</span><br><span class="line">26:                 log.error(&quot;scheduleAtFixedRate flush exception&quot;, e);</span><br><span class="line">27:             &#125;</span><br><span class="line">28:         &#125;</span><br><span class="line">29:     &#125;, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</span><br><span class="line">30: &#125;</span><br></pre></td></tr></table></figure>

<h1 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h1><p><strong>RocketMQ支持局部顺序消息消费</strong>，也就是保证同一个消息队列上的消息顺序消费。<strong>不支持消息全局顺序消费</strong>，如果要实现某一主题的全局顺序消息消费，可以将该主题的队列数设置为1，牺牲高可用性。</p>
<p>官方文档引用</p>
<blockquote>
<p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。RocketMQ可以严格的保证消息有序。</p>
<p>顺序消息分为全局顺序消息与分区顺序消息，全局顺序是指某个Topic下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。</p>
<ul>
<li>全局顺序<br>对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。<br>适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>分区顺序<br>对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。 Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。<br>适用场景：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</li>
</ul>
</blockquote>
<p>参考producer的发送方式，需要指定sharding key。</p>
<h2 id="顺序消费的实现"><a href="#顺序消费的实现" class="headerlink" title="顺序消费的实现"></a>顺序消费的实现</h2><p>顺序消息消费与并发消息消费的第一个关键区别：顺序消息在创建消息队列拉取任务时需要在Broker服务器锁定该消息队列。<br>如果经过消息队列重新负载（分配）后，分配到新的消息队列时，首先需要尝试向Broker发起锁定该消息队列的请求，如果返回加锁成功则创建该消息队列的拉取任务，否则将跳过，等待其他消费者释放该消息队列的锁，然后在下一次队列重新负载时再尝试加锁。</p>
<p><strong>会不会出现当消息队列重新负载时，原先由自己处理的消息队列被另外一个消费者分配，此时如果还未来得及将ProceeQueue解除锁定，就被另外一个消费者添加进去，此时会存储多个消息消费者同时消费一个消息队列？</strong></p>
<p>答案是不会的，因为当一个新的消费队列分配给消费者时，在添加其拉取任务之前必须先向Broker发送对该消息队列加锁请求，只有加锁成功后，才能添加拉取消息，否则等到下一次负载后，只有消费队列被原先占有的消费者释放后，才能开始新的拉取任务。集群模式下，如果未锁定处理队列，则延迟该队列的消息消费。</p>
<h2 id="队列锁的实现"><a href="#队列锁的实现" class="headerlink" title="队列锁的实现"></a>队列锁的实现</h2><p>顺序消息消费的各个环节基本都是围绕消息消费队列（MessageQueue）与消息处理队列（ProceeQueue）展开的。消息消费进度拉取，消息进度消费都要判断ProceeQueue的locked是否为true，设置ProceeQueu巳为true的前提条件是消息消费者（cid）向Broker端发送锁定消息队列的请求并返回加锁成功。</p>
<h1 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h1><p>RocketMQ支持表达式过滤与类过滤两种模式，其中表达式又分为TAG和SQL92。</p>
<p>类过滤模式允许提交－个过滤类到FilterServer，消息消费者从FilterServer拉取消息，消息经过FilterServer时会执行过滤逻辑。</p>
<p>表达式模式分为TAG与SQL92表达式，SQL92表达式以消息属性过滤上下文，实现SQL条件过滤表达式而TAG模式就是简单为消息定义标签，根据消息属性tag进行匹配。</p>
<h2 id="tag过滤的实现"><a href="#tag过滤的实现" class="headerlink" title="tag过滤的实现"></a>tag过滤的实现</h2><p>消息发送者在消息发送时如果设置了消息的tags属性，存储在消息属性中，先存储在CommitLog文件中，然后转发到消息消费队列，消息消费队列会用8个字节存储消息tag的hashcode，之所以不直接存储tag字符串，是因为将ConumeQueue设计为定长结构，加快消息消费的加载性能。</p>
<p><strong>如果直接用字符串匹配的话，过滤时会对服务器造成比较大的压力，字符串匹配需要一个一个去比</strong></p>
<p>在Broker端拉取消息时午，遍历ConsumeQueue，只对比消息tag的hashcode，如果匹配则返回，否则忽略该消息。</p>
<p>Consume在收到消息后，同样需要先对消息进行过滤，只是此时比较的是消息tag的值而不再是hashcode。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mq/" rel="tag"># mq</a>
              <a href="/tags/rocketmq/" rel="tag"># rocketmq</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/04/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/mq/rocketmq/rocketmq03_Broker/" rel="prev" title="rocketmq03_Broker">
      <i class="fa fa-chevron-left"></i> rocketmq03_Broker
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/04/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/mq/rocketmq/rocketmq05_TransactionalMessage/" rel="next" title="rocketmq05_TransactionalMessage">
      rocketmq05_TransactionalMessage <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RocketMQ消息消费概述"><span class="nav-number">1.</span> <span class="nav-text">RocketMQ消息消费概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消息消费流程"><span class="nav-number">2.</span> <span class="nav-text">消息消费流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#消息拉取"><span class="nav-number">2.1.</span> <span class="nav-text">消息拉取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PullMessageService实现"><span class="nav-number">2.1.1.</span> <span class="nav-text">PullMessageService实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息队列负载与重新分布机制"><span class="nav-number">2.2.</span> <span class="nav-text">消息队列负载与重新分布机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#负载均衡的实现"><span class="nav-number">2.2.1.</span> <span class="nav-text">负载均衡的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息消费"><span class="nav-number">2.3.</span> <span class="nav-text">消息消费</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息消费ACK机制-amp-消息重试"><span class="nav-number">2.4.</span> <span class="nav-text">消息消费ACK机制&amp;消息重试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消费进度管理"><span class="nav-number">2.5.</span> <span class="nav-text">消费进度管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#定时消息-amp-消息重试"><span class="nav-number">3.</span> <span class="nav-text">定时消息&amp;消息重试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#延迟级别"><span class="nav-number">3.1.</span> <span class="nav-text">延迟级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#producer发送定时消息"><span class="nav-number">3.2.</span> <span class="nav-text">producer发送定时消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#broker存储定时消息"><span class="nav-number">3.3.</span> <span class="nav-text">broker存储定时消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Broker-发送定时消息"><span class="nav-number">3.4.</span> <span class="nav-text">Broker 发送定时消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Broker-持久化定时发送进度"><span class="nav-number">3.5.</span> <span class="nav-text">Broker 持久化定时发送进度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#顺序消费"><span class="nav-number">4.</span> <span class="nav-text">顺序消费</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序消费的实现"><span class="nav-number">4.1.</span> <span class="nav-text">顺序消费的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列锁的实现"><span class="nav-number">4.2.</span> <span class="nav-text">队列锁的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消息过滤"><span class="nav-number">5.</span> <span class="nav-text">消息过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tag过滤的实现"><span class="nav-number">5.1.</span> <span class="nav-text">tag过滤的实现</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="chenaa"
      src="/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">chenaa</p>
  <div class="site-description" itemprop="description">zZ..zZ..</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenaa</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
